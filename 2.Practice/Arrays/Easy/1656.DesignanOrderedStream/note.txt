1656. Design an Ordered Stream
Easy
Array

Here is a stream of n (id, value) pairs arriving in an arbitrary order,
where id is an integer between 1 and n and value is a string.
No two pairs have the same id.

Design a stream that returns the values in increasing order of their IDs
by returning a chunk (list) of values after each insertion.
The concatenation of all the chunks should result
in a list of the sorted values.

Самое важное, что путает начинающего Хакера это вот это описание ввода.

["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
[[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]

С первого раза ничего не совпадает с описанием. Что это такое?

Если ты опытный хакер, то ты поймешь что ты пишешь код и он вызывается оттуда с другой стороны.
И эти умники ничего лучше не придумали чем написать тебе вызов функций в виде двух массивов. Типа
первый массив это очередность вызываемых функций. Второй массив значения которые получают эти функции.

Выполнение
1. Создаем стрим с определенным количеством элементов у нас это 5,
так как наша тема массивы мы создадим массив с дефолтным количеством элементов.

!учитываем при создании массива стрима
что айдишники значений будут от 1 до n

поведение массивов в каждом языке отличается например
в js Array(5) создаст дефолтные значения,
а вот php python3 не создают так что мы их заполняем в ручную, циклом
пустыми значениями в php null в python3 None в js undefined

2 Теперь непосредственно создание стрима мы все подготовили и создали дефолтный массив

3 сохраняем входящие данные стрима по порядку возрастания айдишника чтобы все было
отсортировано. Этот массив своего рода база данных потом мы будем стравнивать с ней текущее значение

4 создаем переменную результат пустой массив

5 !цикл while - мы не входим в него если условие цикла false.
Создаем цикл, берем нашу базу мы же должны возвращать результат по кускам и по порядку.
Из-за этого мы будем использовать переменную текущая итерация функции которая
вызывается, то есть порядок вызова функции инсерт ее мы записали как индекс.

И продолжаем цикл пока есть значения в базе данных под текущим порядком индекса
этим мы добиваемся непрерывного заполнения массива. Чтобы возвращать куски данных типа
["bbbbb","ccccc"].
Если в базе под текущим порядком есть данные, то записываем их в результат до тех пор, пока они есть
инкрементируем индекс это означает что текущий вызов
функции завершен и мы возвращаем кусок данных в результате.

# причина добавления доп элемента в начальный массив то что в питоне не доступно динамическое
# добавление элементов и питон возвращает ошибку, но php js просто спокойно добавляют новый элемент

