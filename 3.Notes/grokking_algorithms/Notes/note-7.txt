Мы продолжим изучение графов и познакомимся
со взвешенными графами, в которых некоторым ребрам
назначаются большие или меньшие веса .

Вы изучите алгоритм Дейкстры, который позволяет
получить ответ на вопрос «Как выглядит кратчайший
путь к Х?» для взвешенных графов .

Вы узнаете о циклах в графах, для которых алгоритм
Дейкстры не работает.

В предыдущей главе вы узнали , как найти путь из точки А в точку В.
Найденный путь не обязательно окажется самым быстрым . Этот путь
считается кратчайшим, потому что он состоит из наименьшего количества
сегментов (три сегмента).

Но предположим, с каждым сегментом связыва­
ется продолжительность перемещения. И тогда выясняется, что существует
и более быстрый путь.

В предыдущей главе рассматривался поиск в ширину. Этот алгоритм нахо­
дит путь с минимальным количеством сегментов (граф на первом рисунке).
А если вы захотите найти самый быстрый путь (второй граф)? Быстрее
всего это делается при помощи другого алгоритма, который называется
алгоритмом Дейкстры.

Работа с алгоритмом Дейкстры
Посмотрим, как этот алгоритм работает с графом.

Каждому ребру назначается время перемещения в минутах. Алгоритм
Дейкстры используется для поиска пути от начальной точки к конечной
за кратчайшее возможное время .

Применив к этому графу поиск в ширину, вы получите следующий крат­
чайший путь.

page 153

Этот путь занимает 7 минут. А может, существует путь, который займет
меньше времени? Алгоритм Дейкстры состоит из четырех шагов:

1 Найти узел с наименьшей стоимостью (то есть узел, до которого можно
добраться за минимальное время).

2 Обновить стоимости соседей этого узла (вскоре я объясню, что имеется
в виду).

3 Повторять, пока это не будет сделано для всех узлов графа.

4 Вычислить итоговый путь.

шаг 1 найти узел с наименьшей стоимостью. Вы стоите в самом начале
  и думаете, куда направиться: к узлу А или к узлу В. Сколько времени по­
  надобится, чтобы добраться до каждого из этих узлов?

page 153

До узла А вы будете добираться 6 минут, а до узла В - 2 минуты . Что каса-
ется остальных узлов, мы о них пока ничего не знаем.

узел время перехода
A       6
B       2
конец   бесконечно

Так как время достижения конечного узла остается не-
известным, мы считаем, что оно бесконечно (вскоре вы
увидите почему.) Узел В ближайший ... он находится
всего в 2 минутах.

Шаг 2: вычислить, сколько времени потребуется для того, чтобы добраться
до всех соседей В при переходе по ребру из В.

стр 154

узел время перехода
A       5
B       2
конец   7

Ого, да мы обнаружили более короткий путь к узлу А! Раньше для перехода
к нему требовалось 6 минут.

А если идти через узел В, то существует путь, который занимает всего
5 минут!

Если вы нашли более короткий путь для соседа В, обновите его стоимость.
В данном случае мы нашли:

о Более короткий путь к А (сокращение с 6 минут до 5 минут).
о Более короткий путь к конечному узлу (сокращение от бесконечности до 7 минут).

Шаг 3:повторяем!

Снова шаr 1 находим узел, для перехода к которому требуется наименьшее
время. С узлом В работа закончена, поэтому наименьшую оценку времени
имеет узел А.

узел время перехода
A       5
B       2
конец   7

Снова шаr 2: обновляем стоимости соседей А
Путь до конечного узла теперь занимает всего
6 минут!

Алгоритм Дейкстры выполнен для каждого узла (выполнять его для конеч­
ного узла не нужно) . К этому моменту вам известно следующее:

о Чтобы добраться до узла В, нужно 2 минуты.
о Чтобы добраться до узла А, нужно 5 минут.
о Чтобы добраться до конечного узла, нужно 6 минут.

узел время перехода
A       5
B       2
конец   6

Последний шаг - вычисление итогового пути - откладывается до следую­
щего раздела. А пока я просто покажу, как выглядит итоговый путь.

стр 156

Алгоритм поиска в ширину не найдет этот путь как кратчайший, потому
что он состоит из трех сегментов, а от начального узла до конечного можно
добраться все го за два сегмента.

В предыдущей главе мы использовали поиск в ширину для нахождения
кратчайшего пути между двумя точками. Тогда под «кратчайшим путем»
понимался путь с минимальным количеством сегментов. С другой стороны ,
в алгоритме Дейкстры каждому сегменту присваивается число (вес), а ал­
горитм Дейкстры находит путь с наименьшим суммарным весом.

стр 156

На всякий случай повторим: алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно
добраться за минимальное время).
2. Проверить, существует ли более дешевый путь к соседям этого узла,
и если существует, обновить их стоимости.
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь (об этом в следующем разделе!).

Терминология

Я хочу привести еще несколько примеров применения алгоритма Дейкстры.
Но сначала стоит немного разобраться с терминологией.
Когда вы работаете с алгоритмом Дейкстры, с каждым ребром графа свя­
зывается число, называемое весом.

Когда вы работаете с алгоритмом Дейкстры, с каждым ребром графа свя­
зывается число, называемое весом.

стр 157

Граф с весами называется взвешенным графом. Граф без весов называется
невзвешенным графом.

Для вычисления кратчайшего пути в невзвешенном графе используется
поиск в ширину. Кратчайшие пути во взвешенном графе вычисляются по
алгоритму Дейкстры . В графах также могут присутствовать циклы:

стр 158

Это означает, что вы можете начать с некоторого узла, перемещаться по
графу, а потом снова оказаться в том же узле . Предположим , вы ищете
кратчайший путь в графе, содержащем цикл.

Есть ли смысл в перемещении по циклу? Что ж, вы можете использовать
путь без прохождения цикла:

А можете пройти по циклу:

Вы в любом случае оказываетесь в узле А, но цикл добавляет лишний вес.
Вы даже можете обойти цикл дважды, если вдруг захотите.

Но каждый раз, когда вы проходите по циклу, вы только увеличиваете сум­
марный вес на 8. Следовательно, путь с обходом цикла никогда не будет
кратчайшим.

Наконец, вы еще не забыли наше обсуждение направленных и ненаправ­
ленных графов из главы 6?

Само понятие ненаправленного графа означает, что каждый из двух узлов
фактически ведет к другому узлу. А это цикл!

стр 159

В ненаправленном графе каждое новое ребро добавляет еще один цикл. Ал­
горитм Дейкстры работает только с направленными ациклическими графами,
которые нередко обозначаются сокращением
DAG (Directed Acyclic Graph).

История одного обмена

Но довольно терминологии, пора рассмотреть кон­
кретный пример! Это Рама. Он хочет выменять свою
книгу по музыке на пианино.

«Я тебе дам за книгу вот этот постер,
- говорит Алекс. - Это моя любимая группа Destroyer. Или
могу дать за книгу редкую пластинку Рика Эстли и еще
$5». - «0, я слышала, что на этой пластинке
есть отличные песни,  - говорит Эми. - Готова отдать
за постер или пластинку мою гитару или ударную установку».

всю жизнь мечтал играть на гитаре сказал бетховен слушай я отдам тебе свое пианино за людую из вещей эми

Прекрасно! Рама с небольшими дополнительными
тратами может поменять свою книгу на насто­
ящее пианино. Теперь остается понять, как ему
потратить наименьшую сумму на цепочке обменов. Изо­
бразим полученные им предложения в виде графа:

стр 160

Узлы графа - это предметы, на которые может поменяться Рама. Беса
ребер представляют сумму доплаты за обмен. Таким образом, Рама может
поменять постер на гитару за $30 или же поменять пластинку на гитару

за $15. 161 Как Раме вычислить путь от книги до пианино, при котором он
потратит наименьшую сумму? На помощь приходит алгоритм Дейкстры!
Вспомните, что алгоритм Дейкстры состоит из четырех шагов. В этом при­
мере мы выполним все четыре шага, а в конце будет вычислен итоговый
путь

узел стоимость
пластинка 5
постер 0
гитара бесконечно
барабан беск
пианино беск потому что еще не дошли до этого узла

Прежде чем начинать, необходимо немного подготовиться . Постройте та­
блицу со стоимостями всех узлов. (Стоимость узла определяет затраты на
его достижение.)

Таблица будет обновляться по мере работы алгоритма. Для вычисления
итогового пути в таблицу также необходимо добавить столбец «родителм.

узел родитель
пластинка книга
постер книга
гитара -
барабан -
пианино -

Вскоре я покажу, как работает этот столбец. А пока просто запустим алго­
ритм.

Шаг 1: найти узел с наименьшей стоимостью. В данном случае самый де­
шевый вариант обмена с доплатой $0 - это постер. Возможно ли получить
постер с меньшими затратами? Это очень важный момент, хорошенько по­
думайте над ним . Удастся ли вам найти серию обменов, при которой Рама

получит постер менее чем за
$0? Продолжайте читать, когда будете готовы
ответить на вопрос . Правильный ответ: нет, не удастся. Так как постер явля­
ется узлом с наименъшей стоимостъю, до которого может добратъся Рама,
снизить его стоимо с ть невозможно. На происходящее можно взглянуть
иначе: предположим, вы едете из дома на работу.

стр 162

Если вы выберете путь к школе, э то займет
путь к парку, это займет
6 минут.
2
минуты. Если вы выберете Существует ли путь , при котором вы вы­
бираете путь к парку и оказываетесь в школе менее чем за 2 минуты? Это
невозможно , потому что тол ько для того, чтобы попасть в парк, потребует­
ся более 2 минут. С другой стороны, можно ли найти более быстрый путь
в парк? Да , можно.

В этом заключается ключевая идея алгоритма Дейкстры: в графе ищется
путъ с наименъшей стоимостъю . Пути к этому узлу с менъшими затратами
не существует!

Возвращаемся к музыкальному примеру. Вариант с постером обладает наи­
меньшей стоимостью .

Шаг 2: Вычислить, сколько времени потребуется для того, чтобы добраться
до всех его соседей (стоимость).

стр 163

Стоимости бас-гитары и барабана заносятся в таблицу. Они были заданы
при переходе через узел постера, поэтому постер указывается как их роди­
тель. А это означает, что для того, чтобы добраться до бас-гитары, вы про­
ходите по ребру от постера; то же самое происходит с барабаном .

Снова шаг 1: пластинка - следующий по стоимости узел ($5).

Снова шаг 2: обновляются значения всех его соседей.

Смотрите, стоимости барабана и гитары обновились! Это означает, что
к барабану и гитаре дешевле перейти через ребро, идущее от пластинки.
Соответственно, пластинка назначается новым родителем обоих инстру­
ментов.

Следующий по стоимости узел - бас-гитара. Обновите данные его со­
седей.

Хорошо, мы наконец-то вычислили стоимость для пианино при условии
обмена гитары на пианино. Соответственно, гитара назначается родителем.
Наконец, задается стоимость последнего узла - барабана.

Оказывается, Рама может получить пианино еще дешевле, поменяв удар­
ную установку на пианино. Таким образом, самая дешевая цепочка обменов
обойдется Раме в $35.

Теперь, как я и обещал, необходимо вычислить итоговый путь. К этому
моменту вы уже знаете, что кратчайший путь обойдется в $35, но как этот
путь определить? Для начала возьмем родителя узла «пианино».

В качестве родителя узла «пианино» указан узел «барабан».

А в качестве родителя узла «барабан» указан узел «пластинка».\

Следовательно, Рама обменивает пластинку на барабан. И конечно, в самом
начале он меняет книгу на пластинку. Проходя по родительским узлам в об­
ратном направлении, мы получаем полный путь.

Серия обменов, которую должен сделать Рама, выглядит так: стр 166

До сих пор я использовал термин «кратчайший путь » более или менее
буквально, понимая под ним вычисление кратчайшего пути между двумя
точками или двумя людьми. Надеюсь, этот пример показал, что кратчайший
путь далеко не всегда связывается с физическим расстояни ем: он может
быть направлен на минимизацию какой - либо характеристики. В нашем
примере Рама хотел свести к минимуму свои затраты при обмене. Спасибо
Дейкстре!

Ребра с отрицательным весом

В предыдущем примере Алекс предложил в обмен
на книгу один из двух предметов.

Предположим, Сара предложила обменять пла­
стинку на постер и при этом она еще и даст Раме
$7. Рама ничего не тратит при этом обмене, вместо
этого он получит  $7  Как изобразить это предло­
жение на графе?

Ребро, ведущее от пластинки к постеру, имеет отрицательный вес! Если
Рама пойдет на этот обмен, он получит $7. Теперь к постеру можно до­
браться двумя способами.

А значит, во втором обмене появляется смысл - Рама получает $2!

Теперь , если вы помните, Рама может обменять постер на барабан. И здесь
возможны два пути .

Второй путь обойдется на $2 дешевле, поэтому нужно выбрать этот путь, верно?
И знаете что? Если применить алгоритм Дейкстры к этому графу, Рама
выберет неверный путь. Он пойдет по более длинному пути . Алгоритм
Дейкстры не может использоваться при наличии ребер, имеющих отри­
цательный вес. Такие ребра нарушают работу алгоритма. Посмотрим, что
произойдет, если попытаться применить алгоритм Дейкстры к этому графу.
Все начинается с построения таблицы стоимостей.

Теперь найдем узел с наименьшей стоимостью и обновим стоимости его со­
седей. В этом случае постер оказывается узлом с наименьшей стоимостью.
Итак , в соответствии с алгоритмом Дейкстры, к постеру невозможно перей-
mu более дешевым способом, чем с оплатой $0 (а вы знаете, что это неверно!)
Как бы то ни было, обновим стоимости его соседей.

Получается , что теперь стоимость барабана составляет $35
Перейдем к следующему по стоимости узлу, который еще не был обработан.

Обновим стоимости его соседей.

Узел «постер~ уже был обработан, однако вы обновляете его стоимость.
Это очень тревожный признак обработка узла означает, что к нему не-
возможно добраться с меньшими затратами. Но вы только что нашли более
дешевый путь к постеру! У барабана соседей нет, поэтому работа алгоритма
завершена. Ниже приведены итоговые стоимости.

Чтобы добраться до барабанов, Раме потребовалось существует путь, который стоит всего
$35. Вы знаете, что $33, но алгоритм Дейкстры его не на­
ходит. Алгоритм Дейкстры предположил, что, поскольку вы обрабатываете
узел «постер», к этому узлу невозможно добраться быстрее. Это предполо­
жение работает только в том случае, если ребер с отрицательным весом не
существует. Следовательно , использование алгоритма Дейкстры с графом,
содержащим ребра с отрицательным весом, невозможно. Если вы хотите
найти кратчайший путь в графе, содержащем ребра с отрицательным весом,
для этого существует специальный алгоритм, называемый алгоритмом
Беллмана - Форда.
Рассмотрение этого алгоритма выходит за рамки этой
книги, но вы сможете найти хорошие описания в Интернете.

Реализация

Для реализации этого примера понадобятся три хеш - таблицы.

Хеш-таблицы стоимостей и родителей будут обновляться по ходу работы
алгоритма. Сначала необходимо реализовать граф. Как и в главе
6, для этого будет использована хеш-таблица :

В пр едыдущей главе все соседи узла были сохранены в хеш-таблице:

Но на этот раз необходимо сохранить как соседей, так и стоимость перехода
к соседу. Предположим, у начального узла есть два соседа, А и В.

Как представить веса этих ребер? Почему бы не воспользоваться другой
хеш-таблицей?

graph["start"] = {}
graph["start"]["a"] = б
graph["start"]["b"] = 2

получается вложенный массив

Итак , graph("start"] является хеш-таблицей. Для получения всех соседей
начального узла можно воспользоваться следующим выражением:
>>> print graph["start"].keys()
["а",
"Ь"]

Одно ребро ведет из начального узла в А, а другое
- из начального узла в В.
А если вы захотите узнать веса этих ребер?

>>> print graph["start"]["a"]
2
>>> print graph["start"]["b"]
б

Включим в граф остальные узлы и их соседей:

Полная хеш-таблица графа выглядит так:

стр 173

Также понадобится хеш-таблица для хранения стоимо ­
стей всех узлов .

Стоимость узла определяет, сколько времени потребу­
ется для перехода к этому узлу от начального узла. Вы
знаете, что переход от начального узла к узлу В занимает
2 минуты . Вы знаете, что для перехода к узлу А требует­
ся 6 минут (хотя, возможно, вы найдете более быстрый
путь). Вы не знаете, сколько времени потребуется для достижения конечно­
го узла. Если стоимость еще неизвестна, она считается бесконечной. Можно
ли представить бесконечность в PytЬon? Оказывается, ~можно:

infinity = float("inf")

Для родителей также создается отдельная таблица:
Код создания хеш-таблицы родителей:

Након ец, вам нужен массив для отслеживания всех уже обработанных уз­
лов, так как один узел не должен обрабатываться многократно:

На этом подготовка завершается. Теперь обратимся к алгоритму.

Сначала я п риведу код, а пото м мы разберем его более подробно .

Так выглядит алго р итм Д ейк стры на языке Pythoв! Код функции будет
п р иведен далее, а пока рас с мотрим
прим е р ис п ользования алгоритма
в действии

Найти узел с наименьшей стоимостью.

П олучить стоимость и соседей этого узла.

Перебрать соседей.

У каждого узла имеется стоимость, которая определяет, сколько времени
потребуется для достижения этого узла от начала. Здесь мы вычисляем ,
сколько времени потребуется для достижения узла А по пути Начало
Узел В> Узел А (вместо Начало> Узел А).

Сравним эти стоимости.

Мы нашли более короткий путь к узлу А! Обновим стоимость.

Новый путь проходит через узел В, поэтому В назначается новым родителем.

Мы снова вернул ись к началу цикла. Следующим соседом в цикле
for является конечный узел .

Сколько времени потребуется для достижения конечного узла, если идти
через уз ел В?

Потребуется 7 минут. Предыдущая стоимость была бесконечной , а 7 минут
определе нно меньше бесконечности.

Конечному узлу назначается новая стоимость и новый родитель.

Порядок, мы обновили стоимости всех соседей узла В . Узел помечается как
обработанный.

Найти следующий узел для обработки.

Получить стоимость и соседей узла А.

У узла А всего один сосед: конечный узел .

Время достижения конечного узла составляет 7 минут. Сколько времени по­
требуется для достижения конечного узла, если идти через узел А?

Через узел А можно добраться быстрее! Обновим стоимость и родителя.

После того как все узлы будут обработаны, алгоритм завершается. Надеюсь,
этот пошаговый разбор помог вам чуть лучше понять алгоритм. С функцией
find_lowest_cost_node узел с наименьшей стоимостью находится проще
простого. Код выглядит так:

стр 180

Шпаргалка

Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.
Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе.
Алгоритм Дейкстры работает только в том случае, если все веса поло­
жительны.
При наличии отрицательных весов используйте алгоритм Беллмана­
Форда.

















