#Технические вопросы

###Как организовать подготовку

Просмотр задач и ответов не приносит пользы

* Реши задачу самостоятельно (помни о затратах времени и памяти)
* Запишите код алгоритма на бумаге
* Протестируй код на бумаге общие случаи лучшие случаи базовые случаи ошибки и так далее
* Введите написанный код в компьютер как есть
* Имитация собеседований

###Что нужно знать

Сложные вопросы не будут задаваться но лучше быть готовым

|Структуры данных                   |Алгоритмы           |Концепции                                                |
|:---:                              |:---:               |                                                    :---:|
|Связанные списки                   |Поиск в ширину      |Операции с битами                                        |
|Деревья, Нагруженные Деревья, Графы|Поиск в глубину     |Память (стек, куча)                                      |
|Стеки и очереди                    |Бинарный поиск      |Рекурсия                                                 |
|Кучи                               |Сортировка слиянием |Динамическое программирование                            |
|Векторы/ArrayList                  |Быстрая сортировка  |Временная и пространственная сложность (запись О большое)|

* Реализовать сперва на бумаге потом в коде отточить эту таблицу
* Нужно понимать внутреннее строение алгоритмов
* Пиши с нуля если не догоняешь
* Хэш таблицы как пять пальцев

###Таблица степеней двойки

Следующая таблица пригодится во многих задачах, связанных с масштабируемо-
стью или ограничениями памяти

|Степень 2 |Точное значение (х)|Приближенное значение|X байтов в мегабайте,гигабайте и т. д.|
|:---:     |:---:              |                :---:|                                 :---:|
|7         | 128               |                     |                                      |
|8         | 256               |                     |                                      |
|10        | 1024              | 1 тысяча            | 1 Кбайт                              |
|16        | 65 536            |                     | 64 Кбайт                             |
|20        | 1 048 536         | 1 миллион           | 1 Мбайт                              |
|30        | 1 073 741 824     | 1 миллиард          | 1 Гбайт                              |
|32        | 4 294 967 296     |                     | 4 Гбайт                              |
|40        | 1 099 511 627 776 | 1 триллион          | 1 Тбайт                              |


Например, по этой таблице можно легко рассчитать, хватит ли имеющегося объема
памяти для хеш-таблицы, отображающей каждое 32-битное целое число на логи-
ческое значение. Всего существует 2 32 таких чисел. Так как каждое число занимает

один бит, для хранения данных потребуется 2 32 бит (или 2 29 байт). Это соответствует
приблизительно половине гигабайта памяти, поэтому на типичной машине данные
легко поместятся в памяти.
Если вы проходите телефонное собеседование в веб-ориентированной компании,
полезно держать эту таблицу перед глазами.

Полезно держать перед главзами

###Процесс решения задачи

####1. внимательно слушай задачу
* «Имеются два отсортированных массива. Требуется найти...»
  Вероятно, тот факт, что данные отсортированы, должен использоваться в задаче.
  Скорее всего, оптимальный алгоритм для отсортированных данных отличается
  от оптимального алгоритма для ситуации без сортировки.

* «Разработайте алгоритм для многократного выполнения на сервере...»
  Ситуация с многократным выполнением алгоритма на сервере отличается от
  однократного запуска. Возможно, данные стоит кэшировать? А может, в такой
  ситуации будет оправданна разумная предварительная обработка исходного
  набора данных?

1. слушайте
2. представьте пример
3. опишите решение методом грубой силы (не пиши код) просйтой алгоритм и время выполнения
4. оптимизируй
    * оптимизация BUD
    * не используемая информация
    * реши задачу вручную а потом повтори мысленно
    * реши задачу не правильно потом подумай как улучшить задачу
    * попробуй оптимизировать затраты времени и память. Хэш таблицы очень полезны

5. проведи пошаговый разбор. убедись что ты понимаешь алгоритм досконально перед тем как писать код
6. цель написать красивый код. модульный подход и проведи рефакторинг не молчи коментируй
7. протестируй решение
    * концептуальное тестирование пройдись по коду
    * нетипичный или не стандартный код
    * проблемные места арифметика, null узлы
    * маленькие тестовые сценарии они выполняются намного быстрее больших не уступая в эффективности
    * особые и граничные случаи

DUB оптимизация
* узкие места bottleneck
* лишняя работа unnecessary work
* повторяющаяся работа duplicated work

####2 Представьте пример

пример должен быть не самым простым
* конкретным реальные числа и строки
* достаточно большим
* не относящийся к особым случаям

####3 опишите решение методом грубой силы

опиши решение грубой силой пока не оптимально. опиши пространственную и временную сложность

потом оптимизируй

####4 оптимизируй
1. поищи неиспользуемую информацию
2. посмотри новый пример помогает выйти из тупика и обнаружить закономерности
3. решите задачу не правильно
4. время память
5. Проведите предварительную обработку. Возможно ли реорганизовать данные
   (отсортировать и т. д.) или вычислить некоторые значения заранее, чтобы
   сэкономить время в долгосрочной перспективе?
6. Воспользуйтесь хеш-таблицей. Хеш-таблицы часто встречаются в вопросах на
   собеседованиях и должны первыми приходить вам на ум.
7. Подумайте над лучшим ожидаемым временем.

Проанализируйте решение методом «грубой силы» с учетом этих рекомендаций.
Попробуйте исправить недостатки BUD


####5 Пошаговый разбор

Когда оптимальный алгоритм будет найден, не торопитесь переходить к написанию
кода. Выделите немного времени на то, чтобы укрепить свое понимание алгоритма.

При желании напишите псевдокод. Будьте внимательны со стилем. Основные шаги («(1) Провести
поиск в массиве. (2) Найти максимальный элемент. (3) Вставить в кучу») или сокращенная логика
(«if p < q, переместить p иначе переместить q») могут быть полезны. Но если в вашем псевдокоде
появляются циклы for , записанные на английском языке, толку от него будет немного. Вероятно,
быстрее просто написать программный код.

####6 Напишите код

Помните, что короткий фрагмент кода должен продемонстрировать, что вы явля-
етесь выдающимся разработчиком. Учитываются все аспекты — ваш код должен
быть красивым.

* Модульность — признак хорошего стиля программирования. Кроме того,
  она упрощает вашу задачу. Если в вашем алгоритме используется матрица,
  инициализированная элементами {{1, 2, 3}, {4, 5, 6}, ...} , не тратьте время
  на написание кода инициализации. Просто считайте, что у вас есть функция
  initIncrementalMatrix(int size) . Подробности можно будет заполнить позднее,
  если понадобится.

* Проверка ошибок — одни интервьюеры обращают на проверку ошибок большое
  внимание, другие нет. Хороший компромиссный способ — добавить комментарии
  TODO и вслух объяснить, что вы собираетесь проверять.

* Использование других классов/структур, где это уместно. Если функция
  должна вернуть список начальных и конечных точек, можно воспользоваться
  двумерным массивом. Тем не менее лучше передать данные в виде списка объ-
  ектов StartEndPair (или Range ). Приводить подробное описание для каждого
  класса не обязательно. Просто считайте, что класс существует, и займитесь
  подробностями позднее, если останется время.

* Хорошие имена переменных. Код, в котором везде используются однобуквенные
  переменные, плохо читается. Это не означает, что вы не должны использовать
  переменные i и j там, где это уместно (например, в базовом цикле for для
  перебора элементов массива). Тем не менее будьте внимательны: в командах
  вида i = startOfChild(array) для переменной можно найти более удачное имя
  (например, startChild ).

Если ты запутался возращайся к примеру с кодом и разбирай

####7 Переходите к тестированию

Обязательно тестируй код

метод тестирования

1. Начните с концептуального теста. Прочитай и проанализируй каждую строку кода.
2. Поищи странно выглядящий код. Лишний раз проверьте строку
   вида x = length - 2 . Уделите особое внимание циклу for , который начинается
   с i = 1 . Вероятно, это было сделано не просто так, но такие странности повышают
   риск коварных ошибок.

3. На основании своего опыта программирования вы уже знаете, где могут воз-
   никнуть проблемы: базовые случаи в рекурсивном коде; целочисленное деление;
   null -узлы в бинарных деревьях; начало и конец перебора связного списка...
   Лишний раз проверьте эти аспекты.

4. Маленькие тестовые сценарии. Здесь мы впервые применяем конкретный,
   реальный тестовый сценарий для тестирования кода. Не используйте большой
   8-элементный массив, если можно обойтись массивом из 3 или 4 элементов.
   Вероятно, он обнаружит те же ошибки, но сделает это намного быстрее.

5. Особые случаи. Протестируйте свой код на значения null или одноэлементные
   значения, граничные значения и другие особые случаи.

###Метод оптимизации 1: поиск BUD

Под сокращением «BUD» скрываются «узкие места» (Bottlenecks), лишняя работа
(Unnecessary work) и повторяющаяся работа (Duplicated work).

Это три главные причины для неэффективного расходования времени в алгоритмах

Попробуйте проанализировать свое решение методом «грубой силы» и найти в нем эти аспекты.
Обнаружив один из них, сосредоточьтесь на его устранении.

#### Узкие места

«Узким местом» называется часть алгоритма, которая вызывает снижение общего
времени выполнения. Два наиболее распространенных случая:

* Существует однократно выполняемая работа, которая замедляет ваш алгоритм.
  Допустим, вы используете двухфазный алгоритм, который сначала сортирует
  массив, а потом выполняет поиск по некоторому свойству. Первая фаза вы-
  полняется за время O(N log N), а вторая — за время O(N). Возможно, вторую
  фазу удастся сократить до O(log N) или даже O(1), но отразится ли это на
  общем времени? Не особенно. Это второстепенный фактор, так как «узким
  местом» в данном случае является время O(N log N). До тех пор пока первая
  фаза не будет оптимизирована, общая сложность алгоритма так и останется
  равной O(N log N).

* Некоторая часть работы (например, поиск) выполняется многократно. Допустим,
  вам удастся сократить время O(N) до O(log N) или даже O(1). Такая оптимизация
  сильно сократит общее время выполнения.


#### Лишняя работа 64

Пример: вывести все положительные целочисленные решения уравнения а^3 + Ь^3
= с^3 + d^3, где а, Ь, с и d - целые числа в диапазоне от 1 до 1000.

Решение методом «грубой силы просто использует четыре вложенных цикла:

```python3
n = 1000
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            for d from 1 to n
                if a^3 + b^3 == c^3 + d^3
                    print a, b, c, d
                    break
```

Алгоритм перебирает все возможные значения а, Ь, с и d и проверяет, работает ли
текущая комбинация.

алгоритм выполняется за время О(N^4)

Осталась ли еще какая-нибудь лишняя работа? Да. Если для каждой комбинации
( а , Ь, с ) существует только одно возможное значение d, его можно просто вычис­
лить по простой формуле:

d = &#8731; a<sup>3</sup> + b<sup>3</sup> - c<sup>3</sup>

```python3
n = 1000
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            d = pow(a^3 + b^3 - c^3, 1/3)
            if a^3 + b^3 == c^3 + d^3
                print a, b, c, d
```

Время выполнения сокращается с О(No) до О(No).

####Повторяющаяся работа

Для рассмотрения повторяющейся работы мы воспользуемся той же задачей и ал­
горитмом «грубой силы».
По сути, алгоритм перебирает все пары (а, Ь), а затем ищет среди пар ( с , d) со­
впадения для текущей пары ( а , Ь ) .
Зачем продолжать вычислять все пары ( с , d ) для каждой пары ( а , Ь ) ? Список пар
( с , d ) достаточно построить всего один раз. Тогда для каждой пары ( а , Ь ) поиск
будет вестись п о с писку ( с , d ) . Чтобы ускорить поиск совпадения, мы вставим
каждую пару ( с , d ) в хеш-таблицу, связывающую сумму с парой (а вернее, со спи­
ском пар с данной суммой).

```python3
n = 1000
for c from 1 to n
    for d from 1 to n
        result = c^3 + d^3
        append (c, d) to list at value map[result]
for a from 1 to n
    for b from 1 to n
        rresult = a^3 + b^3
        list = map.get(result)
            for each pair in list
                print a, b, pair
                
```

Но если мы построили хеш со всеми парами ( с , d ) , генерировать пары ( а , Ь )
не нужно - каждая пара ( а , Ь ) уже присутствует в хеше

```python3
n = 1000
for c from 1 to n
    for d from 1 to n
        result = c^3 + d^3
        append (c, d) to list at value map[result]
        
for each result, list in map
    for each pair1 in list
        for each pair2 in list
            print pair1, pair2        
```

В этом случае время выполнения сокращается до О(N^2).

####Метод опти мизации 2: и нтуитив н ый подход

Итак, попробуйте решить сложную задачу на интуитивном уровне с реальными
данными. Часто это оказывается проще сделать с большим примером.

Если сравнивать алгоритм с примером из реальной жизни ты сразу придумаешь 
быстрый алгоритм

Например бинарный поиск если ты не слышал о нем и тебе дадут стопку рефератов
и тебе придется искать реферат какого то студента в нем то ты интуитивно 
реализуешь бинарный поиск так и с другими алгоритмами сравни с реальным примером


####Метод оптимизации 3: упрощение и обобщение
####Метод оптимизации 4: базовый случай и расширение
####Метод оптимизации 5: мозговой штурм структур данных

Обратите внимание, что множество задач легко решаются, если правильно выбрать
структуры для используемых данных. Теперь вам нужно развить иитуитивное пред­
ставление о том, какой подход наиболее полезен в той или иной задаче.

###Неправильные ответы

###Если вы уже знаете ответ

###«Идеальный» язык для собеседований

###Распространенность

###Удобочитаемость

###Потенциальные проблемы

###Объем кода

###Простота использования

###Как выглядит хороший код

* Правильно работать
* Эфеективный 
* Простота
* Удобочитаемость
* Удобство сопровождения

Задачи будут сложные нужно просто качнуться до уровня 
чтобы решать 3 4 сложные задачи за раз
1 сложная задача может занять 20-30 минут в идеале









