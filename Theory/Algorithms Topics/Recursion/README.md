
### Recursion

Рекурсивная функция имеет рекурсивынй случай и базовый случай.
В рекурсивном случае она вызывает сама себя в базовом не вызывает
чтобы предотвратить бесконечный цикл.

Пример 

```angular2html
def countdown(i):
    print i
    if i <= 0: //базовый случай
        return
    else:      //рекурсивный случай
        cowntdown n(i-1)

```

Стек вызовов - когда вы вызываете функцию из другой функции
вызывающая функция приостанавливается в частично завершенном состоянии

Все значения переменных этой функции остаются в памяти. И когда 
завершится последняя функция все предыдущие начнут завершатся по
порядку вызова.

Пример 

```angular2html
def greet(name):
    print "hello, " + name + "!"
    greet2(name)
    print "getting ready to say bye..."
    bye()

def greet2(name):
    print "how are you, " + name + "?"
def bye():
    print "ok bye"!
```

1 сначала вызывается функция greet для переменной name = maggie
2 затем функция greet вызывает функцию greet2 для переменной name = maggie
3 на этой стадии функция greet находится в незавершенном, приостановленном состоянии;
4 текущим вызовом функции является вызов greet2
5 после завершения этого вызова функция greet продолжит выполнение.


Теперь рекурсивный пример

!5 = 5 * 4 * 3 * 2 * 1 = 120

```angular2html
def fact(x):
    if x == 1:
        return 1
    else:
        return x * fact(x-1)
```

например мы вызвали fact(3)

```angular2html
код                     стек вызовов
fact(3)                 fact x = 3          первый вызов
if x == 1               fact x = 3
else                    fact x = 3
return x * fact(x -1)   fact x = 2, fact x = 3      рекурсивный вызов
if x == 1               fact x = 2, fact x = 3      текущий вызов первый fact x = 2
else                    fact x = 2, fact x = 3      одна и та же переменная но разные значения
return x * fact(x -1)   fact x = 1, fact x = 2, fact x = 3 обратится к другому значению во время вызова не возможно
if x == 1               fact x = 1, fact x = 2, fact x = 3

это третий вызов и пока ни один вызов не завершился

fact x = 1, первый блок который будет извлечен из стека этот вызов вернет управление и мы его удаляем возвращает 1
fact x = 2,
fact x = 3

fact x = 2,    возвращает 2 return x * fact (x - 1) вызов только что вернувший управление тут x равно 2 эту переменную удаляем
fact x = 3
                                    3         2
fact x = 3      возвращает 6 return x * fact (x - 1) вызов только что вернувший управление
```
Здесь важно, что каждый вызов создает собственную копию х. Обратиться
к переменной х , принадлежащей другой функции, невозможно.
Стек играет важную роль в рекурсии. В начальном примере были представ­
лены два решения поиска ключа. Вспомните, как выглядел первый:

Задача есть коробка в коробке другие коробки а в них маленькие коробки
ключ находится где то там.

Алгоритм без рекурсии на цикле трудный и длинный
Но он быстрее

1 Сложить все коробки в кучу
2 Взять коробку и открыть
3 Если внутри лежит коробка добавить ее в кучу для последующего поиска
4 Если внутри лежит ключ поиск закончен
5 Повторить

В этом случае все коробки лежат в одном месте и вы всегда знаете, в каких
коробках еще нужно искать ключ.

Но в рекурсивном решении никакой кучи не существует.

Алгоритм с рекурсией более понятный и локаничный
Но может быть медленным

1 Посмотерть содержимое коробки
2 Если вы найдете коробку вернуться к шагу 1
3 Если вы найдете ключ поиск завершен

Если кучи нет, то как ваш алгоритм узнает, в каких коробках еще нужно
искать? Пример:

1 проверяем коробку A внутри есть коробки B и C
2 проверяем коробку B в ней лежит коробка D
3 проверяем коробку D она пуста

К этому моменту стек вызовов выглядит примерно так:

box D -
box B -
box A C

коробки которые мы проверяем записываются в стек вызовов
куча коробок хранится в стеке!

Это стек незавершенных вызовов функ­
ции, каждый из которых ведет собственный незаконченный список коробок
для поиска. Стек в данном случае особенно удобен, потому что вам не нуж­
но отслеживать коробки самостоятельно стек делает это за вас.

Стек удобен, но у него есть своя цена: сохранение всей промежуточной
информации может привести к значительным затратам памяти. Каждый
вызов функции занимает не много памяти, но если стек станет слишком
высоким, это будет означать, что ваш компьютер сохраняет информацию
по очень многим вызовам. На этой стадии есть два варианта:

1 Переписать код с использованием цикла.

2 Иногда можно воспользоваться так называемой хвостовой рекурсией.
Это непростая тема, которая выходит за рамки книги. Вдобавок она под­
держивается далеко не во всех языках .

упражнение

Предположим, вы случайно написали рекурсивную функцию, которая
бесконечно вызывает саму себя. Как вы уже видели , компьютер вы­
деляет память в стеке при каждом вызове функции. А что произойдет
со стеком при бесконечном выполнении рекурсии?

Ответ: Стек будет расти бесконечно . Каждой программе выделяется
ограниченный объем памяти в стеке. Когда все пространство будет
исчерпано (а рано или поздно это произойдет) , программа завершится
с ошибкой переполнения стека .

В некоторых языках программирования нет циклов так как они
фугкциональные языки. Аналог циклов это рекурсивный перебор.




