
### Breadth First Search

Time complexity

|       |         |
|:---:  |    :---:|
|Average|      N/A|
|Worst  |/E/ + /V/|

Space complexity 

Worst |V|

[Visualization](https://www.cs.usfca.edu/~galles/visualization/BFS.html)

Поиск в ширину позволяет найти кратчайшее расстояние между двумя объектами.

Граф моделирует набор связей. Каждый граф состоит из узлов и ребер. Узел может быть
соединен с другими узлами они соседи.

Пример поиска в ширину ищем продавца манго 
берем список друзей проверяем есть ли продавец манго 
если нет то добавляем список друзей проверенного человека и так далее.
получается мы проверяем друзей их друзей их друзей и так далее.
в конце мы проверим всю сеть контактов пока не найдем продавца манго 
это и есть поиск в ширину.

два вопроса алгоритма

1 существует ли путь от узла А к Б? (Есть ли продавец манго в вашей сети?)
на этот вопрос мы знаем ответ как проверить список
2 как выглядит кратчайший путь от узла А к Б? (кто из продавцов манго находтся
ближе всего к нам)
 будем считать что наши друзья это связи первого уровня а друзья наших друзей 
связи второго уровня

отсюда следует что нужно сперва пройтись по связям первого уровня полностью а 
потом уже дальше

чтобы проверять связи по очереди мы будем использовать структуру данных очередь

Реализация Графа 

Когда у обьекта нет соседей и стрелки идут только к ним
Направленный граф - отношения действуют только в одну сторону
Ненаправленный граф обьекты соседи друг друга

Время выполнения 

Если поиск продавца прошло по всей сети то значит вы прошлись по
всем ребрам. Значит как минимум время равно O(количество ребер)

Так же в программе хранится очередь поиска добавление в очередь 
O(1) Для каждого человека требуется O(количество людей)
Поиск в ширину выполняется за время O(количество людей + количество ребер)
что обычно записывается в форме O(V+E) (V - количество вершин, 
E - количество ребер)

Если в Графе нет ребер указывающих в обратном направлении то это дерево (разновидность графа)

