
### Djikstra

Алгоритм поиска в ширину ищет кратчайший путь
Алгоритм Дейкстры находит самый быстрый путь

Взвешенные Графы
Алгоритм Дейкстры

Алгоритм Дейкстры состоит из 4 шагов

1 Найти узел с наименьшей стоимостью (то есть узел до которого можно
добраться за мнимальное время)

2 Проверить существует ли более дешевый путь к соседям этого узла
и если существует обновить их стоимости

3 Повторить пока это не будет сделано для всех узлов графа

4 Вычислить итоговый путь (об этом в следующем разделе)

Терминология у каждого ребра есть свой вес число

Граф с весом нзывается взвешенным графом
Граф без веса называется не взвешенным графом

Для поиска кратчайшего пути в не взвешенном графе используют поиск в
ширину

Крайтчайшие пути во взвешенном графе вычисляются алгоримом Дейкстры

В графах так же могут присуствовать циклы

В ненаправленном графе каждое новое ребро добавляет еще один цикл
Алгоритм Дейкстры работает только с направленными ациклическими графами
коротко DAG (Directed Acyclic Graph)

Ребра с отрицательным весом

Алгоритм дейкстры не работает с графом содержащим ребра отрицательным весом

Если вы хотите найти кратчайший путь в графе с ребрами с отрицательным весом 
то нужно использовать алгоритм Беллмана-Форда

Граф можно реализовать хэш таблицей

Реализация Алгоритма Дейкстры

Нам нужно 3 хэш таблицы

Граф

<table id="table1">
  <tr>
    <td>Начало</td>
    <td id="nested">
      <table id="table2">
        <tr>
          <td>A</td>
          <td>6</td>
        </tr>
        <tr>
          <td>B</td>
          <td>2</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>A</td>
    <td id="nested">
      <table id="table2">
        <tr>
          <td>Конец</td>
          <td>1</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>B</td>
    <td id="nested">
      <table id="table2">
        <tr>
          <td>A</td>
          <td>3</td>
        </tr>
        <tr>
          <td>Конец</td>
          <td>5</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>Конец</td>
    <td>-</td>
  </tr>

</table>

```php
$graph = [];
$graph["start"] = [];
$graph["start"]["a"] = 6;
$graph["start"]["b"] = 2;

$graph["a"] = [];
$graph["a"]["fin"] = 1;

$graph["b"] = [];
$graph["b"]["a"] = 3;
$graph["b"]["fin"] = 5;

$graph["fin"] = [];
```

Стоимости

|A    |       6|
|:---:|   :---:|
|B    |       2|
|Конец|Infinity|

```php
$infinity = PHP_INT_MAX;
$costs = [];
$costs["a"] = 6;
$costs["b"] = 2;
$costs["fin"] = $infinity; //пока не проверили
```

по логике мы еще не знаем сколько времени уйдет (стоимость) до 
конечной точки. Пока мы не узнали и не обновили стомость она 
юудет бесконечной.

бесконечность на разных языках по разному в python3

```python3
infinity = float("inf")
```

Родители

|A    |Начало  |
|:---:|   :---:|
|B    |Начало  |
|Конец|-       |

```php
$parents = [];
$parents["a"] = "start";
$parents["b"] = "start";
$parents["fin"] = null; //у конечного узла нет соседей
```

Стоимости и ролители булут обновляться по ходу выполнения
алгоритма

Чтобы реализовать граф каждый язык будет использовать 
свою структуру данных

в Python 3 используем хэш-таблицу

в хэш-таблице будем сохранять соседей с их весами

для получения соседей начального узла просто берем ключи из хэша

```python3
graph["start"]["a"].keys() #["a", "b"]
```
Подготовка закончена
Сам алгоритм

1 Пока остаются не обработанные узлы
2 Взять узел ближайший к началу
3 Обновить стомости для его соседей
4 Если стоимости каких-либо соседей были обновлены
обновить и родителей
5 поместить узел как обработанный (возврашаемся к шагу 1)

* Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.
* Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе.
* Алгоритм Дейкстры работает только в том случае, если все веса поло­
  жительны.
* При наличии отрицательных весов используйте алгоритм Беллмана­
  Форда. 



