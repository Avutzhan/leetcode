
### Big O

Big O время выполнения в худшем случае
то есть в худшем случае нужно сделать n шагов

1 Constant time O(1) потребуется один шаг для выполнения постоянное время

2 Linear Time O(n) потребуется n шагов для выполнения Пример: простой поиск

3 Logarithmic Time O(log n) потребуется log<sub>2</sub>n шагов Пример: бинарный поиск

Повторяем Логарифм log<sub>10</sub>100 означает сколько раз нужно 
перемножить 10 чтобы получить 100. Ответ = 2. 10 х 10 = 100.

Итак = log<sub>10</sub>100 = 2

Логарифм противоположен возведению в степень

Примеры 

10<sup>2</sup> = 100 <=> log<sub>10</sub>100 = 2

10<sup>3</sup> = 1000 <=> log<sub>10</sub>1000 = 3

2<sup>3</sup> = 8 <=> log<sub>2</sub>8 = 3

2<sup>4</sup> = 16 <=> log<sub>2</sub>16 = 4

2<sup>5</sup> = 32 <=> log<sub>2</sub>32 = 5

4 Quadratic Time O(n^2) or O(n<sup>2</sup>) Пример: медленные алгоритмы сортировки (сортировка выбором)

5 Exponential Time

6 O(n * log n) Пример: эффективные алгоритмы сортировки (быстрая сортировка)

7 O(n!) Факториальное время Пример: очень медленные алгоритмы (задача о коммивояжере)

Факториал натурального числа n определяется как произведение всех натуральных чисел от 1 до n включительно

Пример

5! = 1 * 2 * 3 * 4 * 5 = 120

0! = 1

От быстрого к медленному

| Step  | O(log n) | O(n)  | O(n log n) | O(n<sup>2</sup>) | O(n!)                | 
| :---: | :---:    | :---: | :---:      | :---:            | :---:                |
| 16    | 4        | 16    | 64         | 256              | 20 922 789 888 000   |

на самом деле O(n) означает O(c * n)

c - это константа которая имеется почти у каждого алгоритма
то есть если помимо перебора мы выполняем какие то действия
внутри алгоритма то это является константой 
в общем она роли не играет изза этого везде пишут O(n)

пример как константа может не влиять на скорость

Поиск

| линейный                      | бинарный                         |    
|     :---:                     | :---:                            |
| 10ms * n                      | 1s * log n                       |
| 10ms * 4 milliards = 463 days | 1s * 32 = 32s                    |
| const lower but algo is slower| const greater but algo is faster |

Иногда константа может влиять на скорость

Пример

Быстрая сортировка и сортировка слиянием. У быстрой сортировки константа меньше чем
у сортировки слиянием так что не смотря что у обоих время работы O(n log n) быстрая 
сортирока работает быстрее. На приктике быстрая сортировка работает быстрее потому что
средний случай встречается на много чаще худшего 

Средний и худший случай

Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента.
Предположим опорным выбирается всегда первый элемент а быстрая сортировка 
применяется к уже отсортированному массиву

быстрая сортировка не проверяет отсортирован входной массив или нет и все равно
пытается его отсортирвать

как выглядит стек вызово

```angular2html
[1,2,3,4,5,6,7,8]
[] <1> [,2,3,4,5,6,7,8]
[] <2> [3,4,5,6,7,8]
[] <3> [4,5,6,7,8]
[] <4> [5,6,7,8]
[] <5> [6,7,8]
[] <6> [7,8]
[] <7> [8]
```
* стек вызовов переполнен
* первый массив всегда пустой

В качестве опорного элемента берем средний элемент

```angular2html
[1,2,3,4,5,6,7,8]
[1,2,3] <4> [5,6,7,8]
[1] <2> [3]     <6> [7,8]
[] <7> [8]
```

* стек намного короче
* массив каждый раз делится на двое

Первый пример описывает худший сценарий. В худшем случае скорость = O(n)
Второй лучший. В лучщем случае скорость = O(log n)

В нашем случае высота стека равна O(log n) уровней
А так каждый уровень занимает занимает время O(n)

В итоге весь алгоритм занимает O(n) * O(log n) = O(n log n)
Это сценарий лучшего случая.

В худшем случае существует O(n) уровней стека.
В итоге время O(n) * O(n) = O(n<sup>2</sup>)

Лучший и средний случай одно и тоже.

Если вы всегда будете выбирать опорным элементом случайный
элемент в массиве быстрая сортировка в среднем завершится 
за O(n log n). Это один из самых быстрых алгоритмов сортировки
заодно он хорошйи пример для стратегии разделяй и властвуй.


Константы в О большом иногда могут иметь значение по этой причине
быстрая сортировка быстрее сортировки слиянием

При сравнении простой сортировки сс бинарной константа почти никогда 
роли не гирает потому то O(log n) слишком сильно превосходит O(n)
по скорости при большойм размере списка 

