#Тайм-коды: Системы счисления
* 0:00 унарная система счисления
* 3:36 непозиционно-позиционная система счисления (base/основание = 60) часы
* 4:25 Число. Цифра - символ для кодирования (записи) числа
* 8:00 разложение числа на цифры
* 15:00 позиционные системы счисления. Двоичная система счисления
* 17:26 незначащие нули
* 18:30 Бит. Двоичный разряд .Диада
* 22:05 таблица систем счисления (2-ная, 4-ная, 8-ная (триада в двоичном выражении), 10-ная, 16-ная)
* 32:10 развернутая форма записи числа. Перевод из одной системы счисления в другую
* 34:31 к двоичному коду можно дописать нолик слева или справа.
Добавление нуля справа увеличивает число в 2 раза. Незначащий (слева) ноль не меняет числа
* 37:23 шестнадцатеричная система счисления. Тетрада
* 42:05 Байт. Тетрады двоичных цифр. 2 тетрады = 8 диад (8 бит) = 1 байт
* 46:52 схема Горнера. Интерпретация числа. Перевод из одной системы счисления в другую
* 53:42 системы счисления в Питоне. Есть возможность напрямую писать в 2, 8, 10, 16 - ных системах
* 54:03 Литералы чисел в Python. Двоичная: x = 0b1111 (0b  # binary/ бинарный)
* 54:52 восьмеричная: x = 0o07
* 55:15 шестнадцатеричная: x = 0xFA0B
* 55:30 конструктор числа до 36-ной системы счисления. t = int('Z3F', 36) = int('Z3F', base = 36)
* 57:17 print(x)  - выводит любое число в десятичной системе счисления
* 58:02 bin(x) - возвращает строчку двоичного кода
* 58:53 oct(x) - восьмеричное представление числа
* 59:11 hex(x) - 16-ное
* 1:00:32 код, который добывает из числа цифры и собирает в к-л произвольной системе счисления
Перевод числа в другую систему счисления
* 1:02:35 печать без перехода на новую строчку: print(digit, end = "") 
end - именованный параметр. указывает, чем закончить напечатанную строку. '\n' - новая строка
* 1:04:26 взять последнюю цифру (х % base).  зачеркнуть последнюю цифру (х //= base)
* 1:06:34 однопроходные алгоритмы. Подсчет, сумма
* 1:11:10 произведение с 1
* 1:11:30 максимум m = max(m, x)
* 1:12:44 поиск числа в потоке f = f or (x == x0)


унарная система исчисления 
сколько палочек показал = значение

удобно сложить
не удобно писать длинные числа

египтяне придумали собирать унарные однрки в блоки по 5 10 100 заменяя их каким то 
рисунком. 

вавилонцы придумали опозиционную не опозиционную систему исчисления

* Цифра символ для кодирования
* Число это значение символа оно существует вне заивсимости от способа записи

десятеричная система 1 2 3 4 5

таблица двоичной системф

умножение

x 0 1
0 0 0
1 0 1

сложение

+ 0 1
0 0 1
1 0 10 

10 = 2

бит = двоичный разряд

0001
0010

не значящие нули
четыре места куда пожно подставить 0 или 1 называется двичный разряд


двичная 4  8  10
0000    0  0  0
0001    1  1  1 
0010    2  2  2
0011    3  3  3
0100   10  4  4
0101   11  5  5
0110   12  6  6
0111   13  7  7
1000      10  8
1001      11  9
1010      12 10
1011      13 11
1100      14 12
1101      15 13
1110      16 14
1111      17 15

вообще програмисты которые работают с низкоуровневым кодом
знают эту таблицу наизусть
если вдруг начну писать на си какие то драйвера то нужно вернуться к этой теме
и выучить наизусть

схема горнера

способ расшифровки числа

как работать в питоне с такими числами

x = int("z3f", base = 36)
bin(x) вернет цифру в строке как положено а так по дефолту она преобразует в 
человеко понятную цифру двоичная
oct(x) восметиричная
hex(x)  16

# однопроходные алгоритмы
надо обрабатывать одно число было число получили число
было число стало последовательность
была последовательность стало число
                            []  переход
* подсчет n                  0  n += 1
* сумма s                    0  s += x
* произведение p production  1  p *= x
* максимум m                 .  m = max(old_max, x)  => if x>max: m = x  // всгда нужно начальное состояние
* поиск числа f             false  f= old_f or (x or искомое число)                                      // числа пока нет вот и false






