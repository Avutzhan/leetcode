# Тайм-коды: Строки, алгоритм Левенштейна, алгоритм Кнута-Морриса-Пратта
* 4:46 Расстояние Левенштейна. Редакционное расстояние между строками
* 6:00 3 ошибки: 1) перепутали символ, 2) вставили лишний, 3) потеряли нужный
* 8:03 траектория редакционных правок, пространство слов
* 8:52 постановка задачи. функция levenstein (A, B) возвращает минимальное редакционное расстояние. решается методом динамического программирования
* 11:57 Fij - минимальная редакционная правка (редакционное расстояние) между срезами A[:i] и  B[:j] (от начала до i-го и  j-го символа)
* 13:16 редакционное расстояние туда равно редакционному расстоянию обратно
* 13:54 return Fnm
* 14:51 вычисление с помошью рекурсии
* 16:59 Fij = схема решения задачи
* 24:21 алгоритм def levenstein (A, B)
* 25:55 список списков
* 36:39 Проверка равенства строк
* 38:18 есть смысл проверять только строки равноц длины
* 39:26 алгоритм def equal (A,B)  # наивный способ
* 40:57 плюс функций: return - это и флаг и возврат и брейк
* 42:02 второй способ проверки равенства строк - вероятностный
* 43:51 Поиск подстроки в строке
* 49:00 алгоритм def search_substring(s, sub)  # наивный способ
* 54:01 2 функции предобработки строки для дальнейшего поиска
* 54:25 Префикс функция (Pi функция) строки - массив Длин наибольших -//-фиксов для всех строк, заканчивающихся i Соответственно
* 54:54 Собственный суффикс - Суффикс (последние элементы строки), не равный самой строке
* 56:04 Pi s - длина макс с. суффикс = Префикс (первые элементы строки). Сколько элементов сначала равны элементам на конце
* 57:13 постановка задачи. Возвращает максимальную длину -//-фикса, если return Pi[-1]. Но список Pi может содержать большие элементы(большие длины), чем последний (Элемент списка Pi[i] больше, если строка s заканчивалась бы элементом s[i])
* 59:32 Pi = схема решения задачи
Pi s i = префикс функция среза строки s[:i]. Максимальная длина подстроки, для строки заканчивающийся элементом i
* 1:02:13 если S(p+1) == Si
* 1:04:51 если S(p+1) != Si
Т.к. все предыдущие Pi уже известны(посчитаны), чтобы найти Pi для следующего i-го символа, надо теперь рассматривать начало и конец предыдущего начала, разделив теперь уже Его на префикс и суффикс (которые повторяются в остальных фиксах, потому что начало и концы были равны). Т.о. происходит как бы сокращение рассматриваемой области каждый раз примерно вдвое, и уже рассматриваются следующий за этой половиной символ и i-тый
* 1:11:57 алгоритм псевдо поиска подстроки в строке
* 1:16:35 алгоритм псевдо Кнута-Морриса-Пратта (алгоритм КМП)
