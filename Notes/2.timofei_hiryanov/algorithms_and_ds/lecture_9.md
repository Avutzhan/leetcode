# Тайм-коды: Сортировка слиянием, быстрая сортировка Тони Хоара
* 0:24 алгоритм сортировка слиянием. Сортирующее действие - 2 массива (уже отсортированных) в 3-тий
* 2:27 алгоритм слияния двух упорядоченных массивов  # def merge (A: list, B: list)
           1) C = [0]* (len(A)+ len(B))  #  создаем третий список С с len = len(A)+ len(B)
           2) i = k = n = 0              #  делаем по индексу для каждого списка
           3) A[i] < B[k]     # сравниваем элементы в А и В. (Считается, что списки отсортированы по возрастанию) Значит, начиная с самого начала по нулевым индексам, берем меньший из того списка, где меньший
               if A[i] < B[k]   # если в А меньше, то берем из него. А иначе - из В
           4) C[n] = A[i]   # и перекладываем (копируем) его в С
           5) i+=1;  n+=1   # индексы увеличиваются на 1 в тех списках, которые работали 
           6) while    # опять сравниваем элементы в А и В. Делаем это до тех пор, пока или А или В не закончится. 
                while i < len(A) and k < len(B):   # пока оба индекса меньше их длин. Выход будет значить, что или i за пределы А  или k за границы В                                                                    
* 9:12 Устойчивость сортировки
* 10:47 сортируемая характеристика м.б. не единственной и эти реальные объекты м.б. разными
* 13:15 7) while i < len(A) # после верхнего цикла один из списков исчерпан, а в другом еще что-то есть( м.б. и много)
*                                     #  из какого допереливать. Можно  ифом проверить, а можно долить из обоих (ничего и что-то)
* 17:17 8) return C   # теперь С полностью заполнен. Каждый элемент перебирался ровно один раз
* 17:34 удобна другая реализация сортировки, в кот. нет двух списков, а один разбивается на части и индексы с каких по какие       Массив М (left, middle, right)  
* 20:20 merge_sort (A)   # сортировка рекурсивная
* 21:14 len(A) <=1    #  проверка крайнего случая         
* 21:54 выбор интерфейса функции
* 22:40 выделение двух кусков массива (L левый и R правый)
* 25:58 merge_sort (L)  #   кусок опять делится на два и так доход до крайнего случая
merge_sort(R)  #  на обратном ходу рекурсии, после выполнения всех предыдущих merge (L, R), в конце L и R отсортированы
* 26:48 надо слить/отсортировать L и R и запихать в А  #  С = merge (L, R)
* 27:48 нельзя сделать А = С, потому что ссылки
* 30:15 заливка С в А поэлементно циклом
* 33:23 алгоритм сортировки Тони Хоара (Quick Sort). Одна из быстрых сортировок
* 33:46 Timsort в Питоне стандартная сортировка - прагматичная, объединяет несколько алгоритмов сразу.
* 34:10 реализация. Массив и барьерный элемент. barrier = A[0]
* 34:35 случайные числа
* 37:05 функция hoar_sort  .   1) крайний случай, т.к. рекурсия    
* 38:05 return None (type) Когда функция ничего не возвращает 
* 39:05 2) сортирующее действие 3) сортировка кусков
* 39:34 массив на 3 части по принципу отношения к барьерному элемент (L - меньше, M - равные, R - больше)
* 41:20 бег по элементам циклом, индексы не важны
* 42:22 ссылочная модель создания объектов. В Питоне новые объекты появляются единственным способом - методом вычисления выражения (который возвращает объект)
* 45:03 эта реализация треб. доп. памяти больше = массиву А
* 49:21 отличие этих сортировок
* 49:59 алгоритм проверки упорядоченности (отсортированности) массива. Да или нет. За один проход по массиву. Либо по возрастанию либо убыванию
* 50:21 check_sorted (список, возрастание (ascending) = да)
* 52:29 flag = True (массив отсортирован) False - когда встретится хотя бы одна парочка в неправильном порядке
* 55:20 как бул трансформировать в сдвиг вправо или влево на единицу 
* 58:00 бинарный поиск в массиве. Если надо вернуть левую и правую не включающие границы позиций, а не факт наличия и если всегда что-то надо вернуть.
* 1:03:08 логика двоичного поиска. Берем middle = (left + right) //2. left_bound и right_bound   - 2 отдельных поиска. Ненужный просто отбрасываем.

