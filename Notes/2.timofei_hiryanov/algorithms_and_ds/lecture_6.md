# Тайм-коды: Сортировки, объект list
* 1:10 в языке Python список list не является массивом. 
У массива с фиксированным размером надо самостоятельно отслеживать его уровень заполнения
* 3:43 A = []   #  создаем list
* 4:18 у списка не надо самостоятельно отслеживать количество элементов
* 4:34 метод A.append(x)  #  добавление элемента x в конец списка A.
* 5:05 список - динамический массив, модифицируемого размера
* 5:20 функция n = len(A)  #  длина текущего массива, сколько элементов  в массиве, его заполненность
* 5:59 метод A.pop()  #  удаление элемента с конца
* 7:35 Списковые включения (list comprehensions)  #  A = [x**2 for x in range (10)]
* 10:42 цикл for в Питоне спискового характера
* 14:28 if в list comprehension
* 17:10 тернарный оператор
### * 19:00 квадратичные сортировки: количество операций, которое требуется на обработку массива, чтобы его отсортировать равно примерно N**2, где N - длина массива. Асимптотика алгоритма - O (N**2)**
* 20:28 Сортировка вставками (insert sort)
* 26:16 Сортировка выбором (choice sort)
* 29:40 инвариант цикла
* 34:02 N-1 проход в квадратичных сортировках
* 34:19 Сортировка методом пузырька (bubble sort)
* 40:49 количество итераций
* 44:39 мастер-класс по TDD (test-driven development). тестирование
* 46:18 передача функции как параметра в функцию
* 52:02 списки в Питоне можно конкатенировать(складывать)
* 53:15 A = list(range(10, 20))  #  создание списка генератором
* 57:33 sort_algorithm._doc_  #  получить документ-строку
* 58:05 функцию, когда передаем как объект в параметр, пишем без скобок
* 59:35 алгоритм insert_sort(A)
* 1:02:44 while k > 0 and A[k-1] > A[k]:  #  логическое "и" в Питоне Ленивое, т.е. он не будет вычислять второе условие, если первое ложное
* 1:05:11 return из этой функции не требуется, потому что список изменяемый (даже изнутри функции), он уже и так изменится
* 1:05:59 алгоритм choice_sort(A)
* 1:08:03 алгоритм bubble_sort(A)
### * 1:11:53 Сортировка подсчётом (count sort), По времени - O(N), по памяти -O(M), где М - количество различных элементов
* 1:13:50 для маленького диапазона значений. Однопроходный алгоритм
* 1:18:16 частотный анализ

однопроходные алгоритмы

* для посика максимума (несколько максимумов количество элементов равных максимуму все делается за один проход) 
* суммирования последовательности

не надо запоминать все числа если надо тупо просуммировать

частотный анализ

когда считаешь частоту появления каких то цифр

алгоритм подсчетом 
есть прогреммия цифр
делаем частотный анализ
имея результат частотного анализа
печатаем ту цифру столько раз сколько она встречается
и все