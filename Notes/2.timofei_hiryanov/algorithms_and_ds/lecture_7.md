# Тайм-коды: Рекурсия
*   1:13 иллюстрация Репка
*   6:09 в процессе углубления вглубь рекурсии подзадача должна быть проще чем задача
*   6:46 Крайний случай
*   7:11 Рекурсивный случай
*   7:36 иллюстрация Матрёшка
*   9:42 Обратный ход рекурсии. Остаточные действия
*  10:35 функция может позвать сама себя  
           def f():
                f()
*  11:29 переполнение стека вызовов
*  13:22 рекурсия бывает не всегда нужна. Некоторые задачи лучше решить с помощью динамического программирования (циклов). Рекурсия и циклы всегда взаимозаменяемы
*  15:18 алгоритм Матрёшка
*  17:42 1) на прямом ходу рекурсии выполняются коды, которые сверху до вызова функции-самой себя
2) потом проверяется крацний случай
3) на обратном ходу рекурсии (с конца) выполняются коды, которые снизу под вызовом функции-самой себя
* 18:42 у каждого вызова одной и той же функции свой набор имён, своё пространство имён
* 19:44 один вызов функции - её инстанс. Отличие кода функции от её работы
* 22:21 иллюстрация рекурсивный квадрат. Фрактальный квадрат в квадрате
* 24:55 Глубина рекурсии - количество самовызовов, включая внешний
* 25:56 алгоритм fractal_rectangle.    import graphics.py
* 29:01 кортеж.   *A == (A[0], A[1])  #  развертывание итерируемых объектов в параметры функции можно сделать через звездочку перед объектом
* 31:52 for M, N in (A, B), (B, C), (C, D), (D, A):  #  можно несколькими переменными бежать по списку, состоящему из кортежей
* 41:01 Факториал числа
* 45:16 assert (утверждение) #  проверяет условие и выдает ошибку, если условие не верно
* 48:46 этапы хода выполнения алгоритма факториала
* 51:54 алгоритм Евклида вычитанием (наибольший общий делитель)
* 56:49 действия в случае призрака
* 59:06 алгоритм Евклида с помощью деления по модулю
* 1:05:29 быстрое возведение в степень
* 1:15:28 Ханойские башни

