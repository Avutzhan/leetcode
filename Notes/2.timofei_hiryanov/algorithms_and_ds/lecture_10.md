# Тайм-коды: Динамическое программирование, Двумерные массивы
     0:38 реализация бинарного поиска в массиве. Требование - массив отсортирован. Постановка задачи.
     6:11 функция left_bound(A, key) Левая граница
* 16:22 right_bound
* 16:50 скорость бинарного поиска очень высока. Она пропорциональна логарифму от кол-ва элементов.
* 18:50 Одномерное динамическое программирование. Вычисление чисел Фибоначчи и проблема перевычислений. можно сделать разной асимптотикой. 
* 19:35 функция fib(4) С помощью рекурсии - не правильно (и долго и тяжеловесно)
* 20:57 пошаговое выполнение рекурсии
* 24:20 фибоначчиво дерево. Это структура вызовов. Присоединение деревьев fib(4) и fib(3) в fib(5). Кол-во узлов (fib(n)) = числу Фибоначчи, если крайний случай = 1, и т.к. у нас = 0, оно равно следующему числу Фибоначчи. Очень медленно выполнение таким алгоритмом, потому что каждое следующее число отжирает памяти в удвоенном объеме. Т.к. проход до нуля с начала, и так каждый раз.
* 26:48 как надо писать алгоритм Фибоначчи. Делаем массив и прибавляем их циклом for. Здесь наоборот проходы начиная с нуля. 
* 31:30 сравнение этих двух реализаций по памяти ( по времени тем более)
* 34:17 динамическое программирование - это рекурсия вывернутая наоборот. В некоторых видах рекурсии дин. прог. не м.б. реализовано. Например, генерация всех перестановок
* 35:00 классический набор программок для одномерного динамического программирования
* 35:07 Задачи о кузнечике (количество траекторий, траектория наименьшей стоимости). Прыгает вперед на +1 и +2. Сколько различных траекторий допрыгать из 1 в N
* 37:00 типа удобно рекурсией
* 40:31 функция traj_num(n)
* 42:12 усложняем задачку
* 43:15 запрещенные точки + доп. ход на +3
* 43:57 интерфейс такой функции
* 45:04 функция count_trajectories (N, allowed:list)     # allowed - разрешенная/запрещенная точка
* 49:03 [None]    # заполнение массива специальными Ничего
* 50:26 не делать bool == true в ифе, потому что он и так уже
* 51:20 минимальная стоимость достижения клетки N
* 53:45 функция count_min_cost (N, price:list)
* 55:30 пример из реальности
* 58:37 float("-inf")  - числа минус бесконечность и плюс бесконечность. Это числа с плавающей точкой. float('NaN') - Not-a-Number, "нечисло"
* 1:01:14 min() #  питоновская функция минимум из двух чисел
* 1:02:22 траектория попадания
* 1:05:17 Двумерные массивы. В Питоне нет. 2 пути создания:
* 1:05:51 1) линеаризация двумерного массива    A ij (N строк, M эл-в в строке)  -> A[i*M + j]
* 1:08:11 2) список списков
* 1:08:20 неправильное использование списка списков:  A = [ [0] * M] * N  # В результате N раз копируется ссылка на элемент [[0] * M]. И доступ отовсюду к одному объекту.
* 1:10:52 генерация списка. Списковое включение.     A = [ [0] * M for i in range (N)] # так он вычисляет их
* 1:13:12 Оператор is  #  A[0] is A[1] , если A[0] == A[1]  # это False (not is). Смотрится на ссылки, чтобы определить один ли это объект.