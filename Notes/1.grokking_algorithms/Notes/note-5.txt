Хэш таблицы

реализация коллизии и хэш функции

Представьте вы продавец и ищете цены товара в своей книге
если массив не упорядочен то придется искать в каждой строке
проводить простой поиск O(n)

если книга упорядочена по алфавиту то можно использовать бинарный описк
O(log n)

      O(n)   O(log n)
100     10s   1s                log100 = 7
1000    1.66min 1s              log1000 = 10
10000   16.6min  2s             log10000 = 14 операций


получается посик по книге это голованая боль
можно просто завести того кто запомнил все на изусть и когда ты справшиваешь то он просто тебе отвечает без поиска

        O(n)   O(log n)   Помощница O(1)
100     10s         1s              мгновенно
1000    1.66min     1s              мгновенно
10000   16.6min     2s              мгновенно

пока нам известны структуры данных как
массивы, списки, стеки но нормальный поиск в стеках невозможен

если реализовать книгу в виде массива можно использовать бинарный поиск но нам нужно чтобы результат был мгновенный

Хеш-функции

Хеш-функция представляет собой функцию, которая получает строку 1
и возвращает число:

Можно подумать, что найти закономерности получения чисел
для подаваемых на вход строк невозможно. Однако хеш-функция должна
соответствовать некоторым требованиям:

Она должна быть последовательной. Допустим, вы передали ей стро­
ку «апельсины1> и получили 4 Это значит, что каждый раз в будущем,
передавая ей строку «апельсины», вы будете получать 4 ез этого хеш-таблица бесполезна.

Разным словам должны соответствовать разные числа. Например, хеш­
функция, которая возвращает 1 для каждого полученного слова, никуда
не годится. В идеале каждое входное слово должно отображаться на свое
число.

Итак, хеш-функция связывает строки с числами. Зачем это нужно, спросите
вы? Так ведь это позволит нам реализовать Хэш таблицу

например есть пустой массив

[]

нужно записать цену апельсинов передаем хэш функции строку апельсины получаем 3
сохраняем цену апельсинов в массиве под индексом 3

[ , , , 1$]

А теперь вы спрашиваете: сколько стоит авокадо? Искать в массиве ничего
не нужно, просто передайте строку «авокадо» хеш-функции.
Результат показывает, что значение хранится в элементе с индексом 4.
И оно, конечно, там и находится!

Хеш-функция сообщает, где хранится цена, и вам вообще не нужно ничего
искать! Такое решение работает, потому что:

Хеш-функция неизменно связывает название с одним индексом . Каждый
раз, когда она вызывается для строки «авокадо», вы получаете обратно
одно и то же число. При первом вызове этой функции вы узнаете, где
следует сохранить цену авокадо, а при последующих вызовах она со­
общает, где взять эту цену.

Хеш-функция связывает разные строки с разными индексами. «Авока­
до» связывается с индексом 4 а «молоко» - с индексом 0
Для каждой строки находится отдельная позиция массива, в которой сохраняется
цена этого товара.

Хеш-функция знает размер массива и возвращает только действитель­
ные индексы. Таким образом, если длина массива равна 5 элементам,
хеш-функция не вернет 100, потому что это значение не является дей­
ствительным индексом в массиве.

Поздравляю: вы создали « М э гги » ! Свяжите воедино хеш-функцию и мас­
сив, и вы получите структуру данных, которая называется хеш-таблицей.

Хеш-таблица станет первой изученной вами структурой данных, с которой
связана дополнительная логика. Массивы и списки напрямую отображают­
ся на адреса памяти, но хеш-таблицы устроены более умно. Они определяют
место хранения элементов при помощи хе ш-функций.

Вероятно , хеш-таблицы станут самой полезной из сложных структур дан­
ных, с которыми вы по з накомитесь. Они также известны под другими
названиями: «ассоциативны е массивы» , «словари», «отображения», «хеш­
карты» или просто « хеши ». Х еш-табл ицы исключительно быстро работают!

Обращение к элементу массива происходит мгновенно. А хеш-табл ицы используют
массивы для хранения данных, поэтому при обращении к элементам они
не уступают массивам .

Очень важно, чтобы хеш-функции были последова­
тел ьными , то есть неизменно возвращали один и тот
же результат для одинаковых входных данных. Если
это условие будет нарушено, вы не сможете най­
ти свой элемент после того, как он будет помещен
в хеш-таблицу!

Упражнения

Какие из следующих функций являются последовательными?

1 f(x) = 1 Возвращает "1" дnя nюбых входных значений
Ответ : Функция последовательна.
2 f(x) = rand() Возвращает сnучайное чисnо
Ответ: Функция непоследовательна.
3 f(x) = next_empty_slot() Возвращает индекс сnедующеrо пустого эnемента в хеw-табnице
Ответ: Функция непоследовательна.
4 f(x) = len(x)  Возвращает дnину поnученной строки
Ответ: Функция последовательна.

Использование хеш-таблиц для поиска

В вашем телефоне есть удобная встроенная телефонная книга.
С каждым именем связывается номер телефона.

Телефонная книга должна поддер­
живать следующие функции:

добавление имени человека и номера телефона, связанного с этим име­
нем;

получение номера телефона, связанного с введенным именем.

Такая задача идеально подходит для хеш-таблиц! Хеш-таблицы отлично
работают, когда вы хотите :

создать связь, отображающую один объект на другой;
найти значение в списке.
Построить телефонную книгу, в общем-то, несложно. Начните с создания
новой хеш-таблицы:

phone_book["jenny"] = 8675309
print phone_book["jenny"]

Например , представьте, что вы хотите перейти на веб-сайт
- допустим , http/ /adit.io. Ваш компьютер должен преобразовать символическое
имя adit.io в IР-адрес .
Для любого посещаемого веб-сайта его имя преобразуется в IР-адрес
Связать символическое имя с IР-адресом? Идеальная задача для хеш­
таблиц! Этот процесс называется преобразованием DNS. Хеш-таблицы
всего лишь один из способов реализации этой функциональности.

Исключение дубликатов

Предположим, вы руководите избирательным участ­
ком. Естественно, каждый избиратель может про­
голосовать всего один раз. Как проверить, что он не
голосовал ранее? Когда человек приходит голосовать,
вы узнаете его полное имя , а затем проверяете по спи­
ску уже проголосовавших избирателей.

есть в примере кода
Если имя входит в список, значит, этот человек уже проголосовал гоните наглеца!

например если список очень велик то можно воспользоваться хэшем

Если бы имена проголосовавших хранились в списке, то выполнение
функции со временем замедлилось бы, потому что функции пришлось
бы проводить простой поиск по всему списку. Но имена хранятся в хеш­
таблице, а хеш-таблица мгновенно сообщает, присутствует имя избирателя
в списке или нет. Проверка дубликатов в хеш-таблице выполняется очень
быстро.

Шпаргалка
Хеши хорошо подходят для решения следующих задач:
моделирование отношений между объектами;
устранение дубликатов;
кэширование/запоминание данных вместо выполнения работы на сер­
вере.

Коллизии
Чтобы понять быстродействие хеш­
таблиц, необходимо сначала понять, что такое коллизии.

в большинстве языков хэш таблицы уже реализованы на очень хорошем уровне так что
в основном мы будем юзать их а не создавать свои функции так же и с поиском и сортировкой

В следующих двух
разделах рассматриваются коллизии и быстродействие хеш-таблиц.
Прежде всего, я немножко приукрасил действительность. Я сказал, что хеш­
функция всегда отображает разные ключи на разные позиции в массиве.

На самом деле написать такую хеш-функцию почти невозможно. Рассмо­
трим простой пример: допустим, массив состоит всего из 33 ячеек.

И хеш-функция очень простая: элемент массива просто назначается по
алфавитному признаку.

Может быть, вы уже поняли суть проблемы. Вы
хотите поместить цену апельсинов в хеш. Для
этого выделяется первая ячейка.
После апельсинов в хеш заносится цена бананов. Для бананов выделяется
вторая ячейка.
Пока все прекрасно! Но теперь в хеш нужно включить цену авокадо. И для
авокадо снова выделяется первая ячейка.

О нет! Элемент уже занят апельсинами! Что же делать? Такая ситуация
называется коллизией: двум ключам назначается один элемент массива.
Возникает проблема: если сохранить в этом элементе цену авокадо, то она
запишется на место цены апельсинов.

И когда кто-нибудь спросит, сколько
стоят апельсины, вы вместо этого сообщите цену авокадо!

Коллизии -неприятная штука, и вам придется как-то разбираться с ними. Существует
много разных стратегий обработки коллизий. Простейшая из них выглядит
так: если несколько ключей отображаются на один элемент, в этом элементе
создается связанный список.

В этом примере и «апельсины», и «авокадо» отображаются на один элемент
массива, поэтому в элементе создается связанный список. Если вам потре­
буется узнать цену бананов, эта операция по-прежнему выполнится быстро.
Если потребуется узнать цену апельсинов, работа пойдет чуть медленнее.
Вам придется провести поиск по связанному списку, чтобы найти в нем
«апельсины». Если связанный список мал, это не так страшно поиск
будет ограничен тремя или четырьмя элементами. Но предположим, что
вы работаете в специализированной лавке, в которой продаются только
продукты на букву «а».

Одну минуту! Вся хеш-таблица полностью пуста, кроме одной ячейки.
И эта ячейка содержит огромный связанный список! Каждый элемент этой
хеш-таблицы хранится в связанном списке. Ситуация ничуть не лучше той,
когда все данные сразу хранятся в связанном списке. Работа с данными
замедляется.

Из этого примера следуют два важных урока:

выбор хеш-функции действительно важен. Хеш-функция, отображаю­
щая все ключи на один элемент массива, никуда не годится. В идеале
хеш-функция должна распределять ключи равномерно по всему хешу;

если связанные списки становятся слишком длинными, работа с хеш-
таблицей сильно замедляется. Но они не станут слишком длинными при
использовании хорошей хеш-функции!

Хеш-функции играют важную роль. Хорошая хеш-функция создает мини­
мальное число коллизий. Как же выбрать хорошую хеш-функцию? Об этом
в следующем разделе!

Быстродействие

Глава началась с примера магазинчика. Вы хотели построить механизм, ко­
торый мгновенно выдает цены на продукты. Что ж, хеш-таблицы работают
очень быстро.

Быстродействие

Глава началась с примера магазинчика. Вы хотели построить механизм, ко­
торый мгновенно выдает цены на продукты. Что ж, хеш-таблицы работают
очень быстро.

        лучший и средний случай одно и тоже | худший случай
поиск       O(1)                                O(n)
вставка     O(1)                                O(n)
удаление    O(1)                                O(n)

В среднем хеш-таблицы выполняют любые операции за время
0(1).
Время
О( 1) называется постоянным.

Оно не означает, что операции выполняются мгновенно;
просто время остается постоянным независимо от размера хеш-таблицы.

Например, вы знаете, что простой поиск выполняется за линейное время.

Бинарный поиск работает быстрее -за логарифмическое время:

Поиск данных в хеш-таблице выполняется за постоянное время .

Видите горизонтальную линию? Она означает, что при любом размере
хеш-таблицы - 1 элемент или 1 миллиард элементов - выборка данных
займет одинаковое время.

На самом деле вы уже сталкивались с постоянным временем: получение элемента из массива выполняется за постоянное время.

От размера массива оно не зависит. В среднем случае хеш-таблицы
работают действительно быстро.

В худшем случае все операции с хеш-таблицей выполняются за время О(п)
(линейное время), а это очень медленно. Сравним хеш-таблицы с массива­
ми и списками .

            хэш         хэш         массивы         связанные
            лучший      худший                      списки
поиск       O(1)        O(n)        O(1)            O(n)
вставка     O(1)        O(n)        O(n)            O(1)
удаление    O(1)        O(n)        O(n)            O(1)


Взгляните на средний случай для хеш-таблиц. При поиске хеш-таблицы
не уступают в скорости массивам (получение значения по индексу) . А при
вставке и удалении они так же быстры, как и связанные списки. Получается,
что они взяли лучшее от обеих структур! Но в худшем случае хеш-таблицы
медленно выполняют все эти операции, поэтому очень важно избегать
худшего случая быстродействия при работе с хеш-таблицами. А для этого
следует избегать коллизий. Для предотвращения коллизий необходимы :

низкий коэффициент заполнения;

хорошая хеш-функция .

Материал следующего раздела не является обязательным. Речь пойдет о том,
как реализовать хеш-таблицу, но вам никогда не придется делать это само­
стоятельно. Какой бы язык программирования вы ни выбрали, в нем найдет­
ся готовая реализация хеш-таблиц. Вы можете воспользоваться встроенной
реализацией хеш-таблицы, не сомневаясь в том, что она имеет хорошую эф­
фективность. А в следующем разделе мы заглянем во внутреннее устройство
хеш-таблиц.

Внутреннее устройство хэш таблицы

Коэффициент заполнения

Коэффициент заполнения хеш-таблицы вычисляет­
ся по простой формуле .

количество элементов в хэш таблице дробь общее количеств элементов

 х
___

 y

например

[ , 1, , 0, ] коэфицент = 2/3
[ , 20, ] = 1/3

По коэффициенту заполнения
можно оценить количество пустых ячеек в хеш-таблице .

Предположим, в хеш-таблице нужно сохранить цены 100 товаров и хеш­
таблица состоит из 100 элементов. В лучшем случае каждому товару будет
выделен отдельный элемент.

Коэффициент заполнения этой хеш-таблицы равен 1
а если хэш таблица состоит из 50 элементов то коэфицент равен 2
Выделить под каждый товар отдельный элемент ни при каких
условиях не удастся, потому что элементов попросту не хватит!

Коэффициент заполнения больше 1 означает, что количество товаров превышает
количество элементов в массиве.

С ростом коэффициента заполнения в хеш-таблицу приходится добавлять
новые элементы, то есть изменять ее размер . Представим, что эта хеш­
таблица приближается к заполнению.

Хеш-таблицу необходимо расширить. Расширение начинается с создания
нового массива большего размера. Обычно в таком случае создается массив
вдвое большего размера.

Теперь все эти элементы необходимо заново вставить в новую хеш-таблицу
функцией hash:

Новая таблица имеет коэффициент за~олнения 3/8 Гораздо лучше! С мень­
шим коэффициентом загрузки число коллизий уменьшается, и ваша табли­
ца начинает работать более эффективно. Хорошее приближенное правило:

изменяйте размер хеш-таблицы, когда коэффициент заполнения превышает 0,7.
Но ведь на изменение размеров уходит много времени, скажете вы,
и будете абсолютно правы! Да, изменение размеров требует значитель­
ных затрат ресурсов, поэтому оно не должно происходить слишком часто.
В среднем хеш-таблицы работают за время 0(1) даже с изменением размеров.

Хорошая хеш-функция

Хорошая хеш-функция должна обеспечивать равномерное распределение
значений в массиве.

Плохая хеш-функция создает скопления и порождает множество коллизий.

Какую хеш-функцию считать хорошей? К счастью, вам об этом никогда не
придется беспокоиться пусть об этом беспокоятся пожилые бородатые
умники, сидящие в полутемных комнатах . Если вам интересна эта тема,
поищите информацию об алгоритме SHA (короткое описание приведено
в последней главе). Вы можете использовать этот алгоритм в своей хеш­
функции.

Очень важно, чтобы хеш-функции обеспечивали хорошее распределение.
Они должны распределять значения как можно шире. Худший случай -
хеш-функция, которая отображает все значения на одну позицию в хеш­
таблице.

Упражнения

Предположим, имеются четыре хеш-функции, которые получают
строки.

1 Первая функция возвращает «1» для любого входного значения.
2 Вторая функция возвращает длину строки в качестве индекса.
3 Третья функция возвращает первый символ строки в качестве ин­
  декса. Таким образом, все строки, начинающиеся с «а», хешируются
  хешируются в одну позицию, все строки, начинающиеся с «Ь» в другую и т. д.
4 Четвертая функция ставит в соответствие каждой букве про­
  стое число: а=2, Ь=3, с=5, d = 7, е=11 и т. д.
Для строки хеш функцией становится остаток от деления суммы всех значений на
размер хеша. Например, если размер хеша равен 10 то для строки
bag будет вычислен индекс 3 + 2 + 17 % 10 = 22 % 10 = 2

В каком из этих примеров хеш-функции будут обеспечивать хорошее рас пределение?
Считайте , что хеш-таблица содержит 10 элементов.

1 Телефонная книга, в которой ключами являются имена, а значениями номера телефонов.
Задан следующий список имен: Esther, Ben, ВоЬ, Dan
Ответ: Хеш-функции С и D беспечивают хорошее распределение.

2 Связь размера батарейки с напряжением. Размеры батареек: А, АА,
ААА,АААА.
Ответ: Хеш-функции B и D беспечивают хорошее распределение.

3 Связь названий книг с именами авторов. Названия книг: Maus Fun Home Watchmen
Ответ: Хеш-функции B,С и D беспечивают хорошее распределение.

Шпаргалка
Хеш-таблицы чрезвычайно полезны, потому что они обеспечивают высокую
скорость операций и позволяют по-разному моделировать данные. Воз­
можно, вскоре выяснится, что вы постоянно используете их в своей работе.

1 Хеш-таблица создается объединением хеш-функции с массивом.
2 Коллизии нежелательны. Хеш -функция должна свести количество кол­
  лизий к минимуму.
3 Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки
  и удаления.

4 Хеш-таблицы хорошо подходят для моделирования отношений между
  объектами.

5 Как только коэффициент заполнения превышает 0,7, пора изменять размер хеш-таблицы .

6 Хеш-таблицы используются для кэширования данных (например, на
  веб-серверах )

7 Хеш-таблицы хорошо подходят для обнаружения дубликатов.









