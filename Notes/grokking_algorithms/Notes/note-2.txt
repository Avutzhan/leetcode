Массив это структура данных
то есть это особый способ организации данных в памяти компьютера.

Список абстрактный тип данных
то есть любая структура данных, которая поддерживает определенный набор операций.
Слово «абстрактный» означает, что вы можете реализовать его любым количеством способов.
то есть чтобы реализовать список мы можем использовать сам массив или реализовать при помощи
других инструментов


При использовании массива все задачи
хранятся в памяти непрерывно (то есть рядом
друг с другом).

Теперь предположим, что вы захотели добавить четвертую задачу. Но сле­
дующий ящик уже занят
-
там лежат чужие вещи!

Представьте, что вы пошли в кино с друзьями и нашли места для своей ком­
пании, но тут приходит еще один друг, и ему сесть уже некуда. Приходится
искать новое место, где смогут разместиться все. В этом случае вам при­
дется запросить у компьютера другой блок памяти, в котором поместятся
все четыре задачи, а потом переместить все свои задачи туда.

вот так работает массив с памятью в начале ты запрашиваешь место и кладешь туда данные
но если хочешь добавить еще одно тебе придется повторить запрос уже на 1 больше и все
перемещается в другое место и так постоянно при добавлении нового элемента

то есть добавление новго элемента в массив будет очень долгим потому что все постоянно приходится
перемещать в другой блок памяти

Связанные списки

При использовании связанного списка элементы могут размещаться где
угодно в памяти.

В каждом элементе хранится адрес следующего элемента списка . Таким
образом, набор произвольных адресов памяти объединяется в цепочку.

то есть при добавлении нового элемента он добавляется в свободную ячейку памяти и
указывает на следующий элемент так работает список с памятью

До­
там написано : «Следующий элемент находится по адресу
бавить новый элемент в связанный список проще простого: просто разме­
стите его по любому адресу памяти и сохраните этот адрес в предыдущем
элементе.

но чтобы найти определенный элемент придется пройти по всему списку
Со связанными списками ничего перемещать в памяти не нужно.

Связанные списки подходят только тогда когда нужно читать данные последовательно
Но если вы намерены прыгать по
списку туда-сюда, держитесь подальше от связанных списков.
С массивами дело обстоит совершенно иначе. Работая с массивом, вы за­
ранее знаете адрес каждого его элемента.

Массивы прекрасно подхо­
дят для чтения элементов в произвольных позициях, потому что обращение
к любому элементу в массиве происходит мгновенно.

Примеры времени выполнения основных операций с массивами

        массивы списки
чтение    O(1)    O(n)
вставка   O(n)    O(1)

O(n) линейное время
O(1) Постоянное время

почему так мы рассмотрели выше

Упражнение 1

опустим, вы строите приложение для управления финансами.
1 продукты
2 кино
3 велосипедный клуб

Ежедневно вы записываете все свои траты. В конце месяца вы анали­
зируете расходы и вычисляете, сколько денег было потрачено. При
работе с данными выполняется множество операций вставки и отно­
сительно немного операций чтения. Какую структуру использовать
-
массив или список?

В данном случае траты добавляются в список ежедневно,
а чтение всех данных происходит один раз в месяц. Для массивов
характерно быстрое чтение и медленная вставка, а для связанных
списков
-
медленное чтение и быстрая вставка. Так как вставка будет
выполняться намного чаще, чем чтение, есть смысл воспользоваться
связанным списком. Кроме того, чтение в связанных списках происхо­
дит медленно только при обращении к случайным элементам списка.
Так как читаться будут все элементы списка, связанный список также
неплохо справится с чтением. Итак, связанный список станет хорошим
решением этой задачи.

при условии что раз в месяц используется чтение списка и каждый день вставка

****Вставка в середину списка

Предположим, вы решили, что список задач должен больше напоминать
календарь. Прежде данные добавлялись только в конец списка, а теперь
они должны добавляться в порядке их выполнения.

Со списком задача решается изменением указателя в предыдущем элементе.
А при работе с массивом придется сдвигать вниз все остальные элементы.
А если свободного места не осталось, все данные придется скопировать
в новую область памяти! В общем, списки лучше подходят для вставки
элементов в середину.

****Удаление

Что, если вы захотите удалить элемент? И снова список лучше подходит
для этой операции, потому что в нем достаточно изменить указатель в пре­
дыдущем элементе. В массиве при удалении элемента все последующие
элементы нужно будет сдвинуть вверх.

        массивы списки
чтение    O(1)    O(n)
вставка   O(n)    O(1)
удаление  O(n)    O(1)

Массивы чрезвычайно
популярны из-за того, что они поддерживают произвольный доступ. Всего
существуют два вида доступа: произвольный и последовательный.

Многие реальные ситуа­
ции требуют произвольного доступа, поэтому массивы часто применяются
на практике.

Также массивы и списки используются для реализации других
структур данных (о которых будет рассказано в книге далее).

Упражнение 2

Допустим, вы пишете приложение для приема заказов от посетителей
ресторана. Приложение должно хранить список заказов. Официанты
добавляют заказы в список, а повара читают заказы из списка и вы­
полняют их. Заказы образуют очередь: официанты добавляют заказы
в конец очереди , а повар берет первый заказ из очереди и начинает
готовить.

акую структуру данных вы бы использовали для реализации этой оче­
реди-массив или связанный список? (Подсказка: связанные списки
хорошо подходят для вставки/удаления, а массивы
для произвольного доступа к элементам. Что из этого понадобится в данном случае?)

Ответ: Связанный список. Вставка происходит очень часто ( офици­
анты добавляют заказы), а связанные списки эффективно выполняют
эту операцию. Ни поиск, ни произвольный доступ (сильные стороны
массивов) вам не понадобятся, потому что повар всегда извлекает из
очереди первый заказ.

Упражнение 2

Проведем мысленный эксперимент. Допустим,Facebook хранит
список имен пользователей. Когда кто-то пытается зайти на сайт
Facebook, система пытается найти имя пользователя. Если имя входит
в список имен зарегистрированных пользователей, то вход разреша­
ется. Пользователи приходят на Facebook достаточно
часто, поэтому поиск по списку имен пользователей будет выполняться часто. Будем
считать, что Facebook использует бинарный поиск для поиска в спи­
ске. Бинарному поиску необходим произвольный доступ - алгоритм
должен мгновенно обратиться к среднему элементу текущей части
списка. Зная это обстоятельство, как бы вы реализовали список поль­
зователей - в виде массива или связанного списка?

Ответ: В виде отсортированного массива. Массивы обеспечивают
произвольный доступ - вы можете мгновенно получить элемент из
середины массива. Со связанными списками это невозможно. Чтобы
получить элемент из середины связанного списка, вам придется начать
с первого элемента и переходить по ссылкам до нужного элемента.

Упражнение 3

Пользователи также довольно часто создают новые учетные записи на
Facebook. Предположим, вы решили использовать массив для хране­
ния списка пользователей. Какими недостатками обладает массив для
выполнения вставки? Допустим, вы используете бинарный поиск для
нахождения учетных данных. Что произойдет при добавлении новых
пользователей в массив?

Ответ: Вставка в массив выполняется медленно. Кроме того, если вы
используете бинарный поиск для нахождения имен пользователей,
массив необходимо отсортировать. Предположим, пользователь по
имени Adit В регистрируется на Facebook. Его имя будет вставлено
в конец массива. Следовательно, массив нужно будет сортировать при
каждой вставке нового имени!

Упражнение 4
В действительности Facebook не использует ни массив, ни связанный
список для хранения информации о пользователях. Рассмотрим ги­
бридную структуру данных : массив связанных списков. Имеется мас­
сив из 26 элементов. Каждый элемент содержит ссылку на связанный
список. Например, первый элемент массива указывает на связанный
список всех имен пользователей, начинающихся на букву «А~. Второй
элемент указывает на связанный список всех имен пользователей, на­
чинающихся на букву «В~, и т. д.

Предположим, пользователь с именем в «Adit в~ регистрируется
Facebook и вы хотите добавить его в список. Вы обращаетесь к элементу
1 массива, находите связанный список элемента 1 и добавляете

«Adit В» в конец списка. Теперь предположим, что зарегистрировать
нужно пользователя «Zakhir Н». Вы обращаетесь к элементу 26, ко­
торый содержит связанный список всех имен, начинающихся с «Z~, И проверяете, присутствует ЛИ
«Zakhir Н~ В ЭТОМ списке.

Теперь сравните эту гибридную структуру данных с массивами и свя­
занными списками. Будет она быстрее или медленнее каждой исход­
ной структуры при поиске и вставке? Приводить время выполнения
«О-большое» не нужно, просто выберите одно из двух: быстрее или
медленнее.

Ответ: Поиск - медленнее, чем для массивов, и быстрее , чем для
связанных списков. Вставка - быстрее, чем для массивов, и с такой же
скоростью для связанных списков. Итак, гибридная структура уступа­
ет массиву по скорости поиска, но по крайней мере не хуже связанных
списков для всего остального. Далее в книге будет рассмотрена другая
гибридная структура данных, называемая хеш-таблицей. Она даст не­
которое представление о том, как строить сложные структуры данных
из более простых.

Что же в действительности использует сервис Facebook?
Вероятно, десяток разных баз данных, за которыми стоят разные структуры
данных: хеш-таблицы, в-деревья и т. д. Массивы и связанные списки
становятся структурными элементами для построения более сложных
структур данных.

Сртировка выбором

А теперь объединим все, что вы узнали, во вто­
ром алгоритме: сортировке выбором. Чтобы ос­
воить этот алгоритм, вы должны понимать, как
работают массивы и списки и «О-большое~.
Допустим, у вас на компьютере записана музы­
ка и для каждого исполнителя хранится счет­
чик воспроизведений.

Вы хотите отсортировать список по убыванию счетчика воспроизведений,
чтобы самые любимые исполнители стояли на первых местах . Как это
сделать?
Одно из возможных решений
-
пройти по списку и найти исполнителя
с наибольшим количеством воспроизведений . Этот исполнитель добавля­
ется в новый список.

Потом то же самое происходит со следующим по количеству воспроизве­
дений исполнителем .

Продолжая действовать так, мы получаем отсортированный список.

А теперь попробуем оценить происходящее с точки зрения теории вычис­
лений и посмотрим, сколько времени будут занимать операции. Напомним,
что время О(п) означает, что вы по одному разу обращаетесь к каждому
элементу списка. Например, прИ: простом поиске по списку исполнителей
каждый исполнитель будет проверен один раз.

Чтобы найти исполнителя с наибольшим значением счетчика воспроиз­
ведения , необходимо проверить каждый элемент в списке. Как вы уже
видели, это делается за время О(п). Итак, имеется операция, выполняемая
за время О( п ), и ее необходимо выполнить п раз :

уменьшение количества проверяемых элементов

при каждой проверкке количество элементов сокращается на одну.
со временем все ведется к проверке только одного элемента
так почему же время выполнения O(n)

ответ связан с ролью констант в о большом

рассмотрим это в главе 4

а сейчас кратко рассмотрим этот вопрос

сначала проверяем n элементов потом n - 1, n -2 и так далее

в среднем проверяем список 1/2 * n элементов

время выполнения будет O(n * 1/2 * n)

но константы как 1/2 игнорятся в большом О         2
поэтому мы просто используем O(n * n)           O(n )

Алгоритм сортировки выбором легко объясняется, но медленно работает.

Быстрая сортировка эффективный алгоритм сортировки, который выполняется за время О(п log п).


в примере есть функция реализация алгоритма сортировки выбором она выполняет сортировку
массива по возрастанию.

Напишем функцию для поиска наименьшего
элемента массива:

Теперь на основе этой функции можно написать функцию сортировки вы­
бором:

Шпаргалка
Память компьютера напоминает огромный шкаф с ящиками.

Если вам потребуется сохранить набор элементов, воспользуйтесь мас­
сивом или списком.

В массиве все элементы хранятся в памяти рядом друг с другом.

В списке элементы распределяются в произвольных местах памяти, при
этом в одном элементе хранится адрес следующего элемента.

Массивы обеспечивают быстрое чтение.

Списки обеспечивают быструю вставку и выполнение.

Все элементы массива должны быть однотипными (только целые числа,
только вещественные числа и т. д.).



























