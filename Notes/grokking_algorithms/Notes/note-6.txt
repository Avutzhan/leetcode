Вы научитесь моделировать сети при помощи новой абстрактной структуры данных  графов

Вы освоите поиск в ширину  алгоритм, который применяется к графам для получения ответов на вопросы
вида «Какой кратчайший путь ведет к Х?»

Вы узнаете, чем направленные графы отличаются от
ненаправленных.

Вы освоите топологическую сортировку другой алго­
ритм сортировки, раскрывающий связи между узлами.

Эта глава посвящена графам. Сначала вы узнаете, что такое граф. Затем
я покажу первый алгоритм, работающий с графами. Он называется поиском
в ширину (BFS, Breadth-First Search).

Поиск в ширину позволяет найти кратчайшее расстояние между двумя объ­
ектами. Однако сам термин «кратчайшее расстояние» может иметь много
разных значений! Например, с помощью поиска в ширину можно:

написать программу для игры в шашки, которая вычисляет кратчайший
путь к победе;

реализовать проверку правописания (минимальное количество измене­
ний, преобразующих ошибочно написанное слово в правильное, напри­
мер АЛГОРИФМ ->АЛГОРИТМ одно изменение);

найти ближайшего к вам врача.

Одни из самых полезных алгоритмов, известных мне, работают с графами.

Знакомство с графами

Предположим, вы находитесь в Сан-Франциско и хотите добраться из
Твин-Пике к мосту Золотые Ворота. Вы намереваетесь доехать на автобусе
с минимальным количеством пересадок. Возможные варианты:

Графы похожи на таблици связей между обьектами в UML BPMN вформате

Какой алгоритм вы бы использовали для поиска пути с наименьшим коли­
чеством шагов?

Можно ли сделать это за один шаг? На следующем рисунке выделены все
места, в которые можно добраться за один шаг.

Мост на этой схеме не выделен; до него невозможно добраться за один шаг.
А можно ли добраться до него за два шага?

И снова мост не выделен, а значит, до него невозможно добраться за два
шага. Как насчет трех шагов?

Ага! На этот раз мост Золотые Ворота выделен. Следовательно, чтобы до­
браться из Твин-Пике к мосту по этому маршруту, необходимо сделать три
шага.

Есть и другие маршруты, которые приведут вас к мосту, но они длиннее
(четыре шага). Алгоритм обнаружил, что кратчайший путь к мосту состоит
из трех шагов. Задача такого типа называется задачей поиска кратчайшего
пути. Часто требуется найти некий кратчайший путь: путь к дому вашего
друга, путь к победе в шахматной партии (за наименьшее количество ходов)
и т. д . Алгоритм для решения задачи поиска кратчайшего пути называется
поиском в ширину .

Чтобы найти кратчайший путь из Твин-Пике к мосту Золотые Ворота, нам
пришлось выполнить два шага:

1 Смоделировать задачу в виде графа.
2 Решить задачу методом поиска в ширину.

В следующем раздел е я расскажу, что такое графы. Затем будет рассмотрен
более подробно поиск в ширину.

Что такое граф?

Граф моделирует набор связей. Пред­
ставьте, что вы с друзьями играете в по­
кер и хотите смоделировать, кто кому
сейчас должен. Например, условие
«Алекс должен Раме» можно смодели­
ровать так:

алекс -> рама

Алекс должен Раме, Том должен Адиту и т. д. Каждый граф состоит из узлов
и ребер.

стр 132 рисунок

Бот и все! Графы состоят из узлов и ребер. Узел может быть напрямую со­
единен с несколькими другими узлами. Эти узлы называются соседями. На
этом графе Рама является соседом Алекса. С другой стороны, Адит соседом
Алекса не является, потому что они не соединены напрямую . При этом Адит
является соседом Рамы и Тома.

Графы используются для моделирования связей между разными объектами .
А теперь посмотрим, как работает поиск в ширину.

В главе 1 уже рассматривался пример алгоритма поиска: бинарный по­
иск. Поиск в ширину также относится к категории алгоритмов поиска,
но этот алгоритм работает с графами. Он помогает ответить на вопросы
двух типов:
тип 1: существует ли путь от узла А к узлу В?
тип 2: как выглядит кратчайший путь от узла А к узлу В?

Бы уже видели пример поиска в ширину, когда мы просчитывали кратчай­
ший путь из Твин-Пике к мосту Золотые Ворота. Это был вопрос типа
2: как выглядит кратчайший путь? Теперь разберем работу алгоритма более
подробно с вопросом типа 1: существует ли путь?

Представьте, что вы выращиваете манго. Бы ищете продавца, который
будет продавать ваши замечательные манго. А может, продавец найдется
среди ваших контактов на Facebook?
Для начала стоит поискать среди друзей.

у вас есть три друга алиса клэр и боб

Поиск происходит вполне тривиально.
Сначала нужно построить список друзей для поиска.
Теперь нужно обратиться к каждому человеку в списке
и проверить, продает ли этот человек манго.
Предположим , ни один из ваших друзей не продает манго. Теперь поиск
продолжается среди друзей ваших друзей .

картинка стр 134

Каждый раз, когда вы проверяете кого-то из списка, вы добавляете в список
всех его друзей.

В таком случае поиск ведется не только среди друзей, но и среди друзей
друзей тоже.

Напомним: нужно найти в сети хотя бы одного продавца ман­
го. Если Алиса не продает манго, то в список добавляются ее друзья . Это
означает, что со временем вы проверите всех ее друзей, а потом их друзей
и т. д . С эти м алгоритмом поиск рано или поздно пройдет по всей сети , пока
вы все-таки не наткнетесь на продавца манго. Тако й алгоритм и называется
поиском в ширину.

Поиск кратчайшего пути

На всякий случай напомню два вопроса, на которые может ответить алго­
ритм поиска в ширину:

тип 1: существует ли путь от узла А к узлу В? (Есть ли продавец манго
в вашей сети?)
тип 2: как выглядит кратчайший путь от узла А к узлу В? (Кто из про­
давцов манго находится ближе всего к вам?)

Вы уже знаете, как ответить на вопрос вопрос 1;.
теперь попробуем ответить на 2
Удастся ли вам найти ближайшего продавца манго? Будем счи ­
тать, что ваши друзья это связи первого уровня, а друзья друзей связи второго уровня.

Связи первого уровня предпочтительнее связей второго уровня, свя зи
второго уровня предпочтительнее связей третьего уровня и т. д. Отсюда
следует, что поиск по контактам второго уровня не долже н производить­
ся, пока вы не будете полностью уверены в том, что среди связей первого
уровня нет ни одного продавца манго. Но ведь поиск в ширину именно это
и делает! Поиск в ширину распространяется от начальной точки. А это оз­
начает, что связи первого уровня будут проверены до связей второго уровня.
Контрольный вопрос: кто будет проверен первым , Клэр или Анудж? Ответ:

Клэр является связью первого уровня, а Анудж - связью второго уровня.
Следовательно, Клэр будет проверена первой.

Также можно объяснить это иначе: связи первого уровня добавляются
в список поиска раньше связей второго уровня.

Вы двигаетесь вниз по списку и проверяете каждого
человека (является ли он продавцом манго). Связи
первого уровня будут проверены до связей второго
уровня, так что вы найдете продавца манго, ближай­
шего к вам. Поиск в ширину находит не только путь
из А в В, но и кратчайший путь.

Обратите внимание: это условие выполняется только
в том случае, если поиск осуществляется в порядке
добавления людей. Другими словами, если Клэр была
добавлена в список до Ануджа, то проверка Клэр должна быть выполнена
до проверки Ануджа. А что произойдет, если вы проверите Ануджа раньше,
чем Клэр, и оба они окажутся продавцами манго? Анудж является связью
второго уровня, а Клэр - связью первого уровня. В результате будет найден
продавец манго, не ближайший к вам в сети. Следовательно, проверять свя­
зи нужно в порядке их добавления. Для операций такого рода существует
специальная структура данных, которая называется очередью.

Очереди структуры данных

Очередь работает точно так же, как
и в реальной жизни. Предполо­
жим, вы с другом стоите в очереди
на автобусной остановке. Если вы
стоите ближе к началу очереди, то
вы первым сядете в ;штобус. Струк­
тура данных очереди работает ана­
логично. Очереди чем-то похожи
на стеки: вы не можете обращаться
к произвольным элементам очере­
ди . Вместо этого поддерживаются
всего две операции: постановка
в очередь и извлечение из очереди.

Если вы поставите в очередь два элемента, то элемент, добавленный пер­
вым, будет извлечен из очереди раньше второго. А ведь это свойство можно
использовать для реализации списка поиска! Люди , добавленные в список
первыми, будут извлечены из очереди и проверены первыми .

Очередь относится к категории структур данных
FIFO: First In, First Out
(«первым вошел, первым вышел»).
А стек принадлежит к числу структур данных
LIFO: Last In, First Out
(«последним пришел , первым вышел»).

Теперь, когда вы знаете, как работает очередь, можно переходить к реали­
зации поиска в ширину!

Очередь как реальная очередь первым вошел первым вышел
1, 2, 3, 4
А стек как стопка листов друг на друге последний пришел но так как последний листок стоит на верху его и первым извлекут

Упражнения

Примените алгоритм поиска в ширину к каждому из этих графов, чтобы
найти решение.

1 Ответ: Длина кратчайшего пути равна 2.

2 Ответ: Длина кратчайшего пути равна 2.

Реализация Графа

Для начала необходимо реализовать граф
на программном уровне . Граф состоит из
нескольких узлов. И каждый узел соединя ­
ется с соседними узлами. Как выразить от ­
ношение типа «вы - > боб»? К счастью, вам
уже известна структура данных, способная
выражать отношения: хеш-таблица!

Вспомните: хеш-таблица связывает ключ
со значением. В данном случае узел должен
быть свя з ан со всеми его соседями.

вы -> алиса боб клэр

А вот как это записывается на Python:

graph = {}
graph['you'] = ['alice', 'bob', 'claire']

Обратите внимание: элемент «в ы ~ (you) отображается на массив. Следова­
тельно, результатом выражения graph[ "you"] является массив всех ваших
соседей.

Граф на - всего лишь набор узлов и ребер, поэтому для представления графа
Python ничего больше не потребуется. А как насчет большего 1·рафа, на­
пример такого?

Код на языке Python выглядит так:

graph = {}
graph [ "you"] = [ "alice", " ЬоЬ", "claire"]
graph("bob"] = ("anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph("jonny"] = []

Контрольный вопрос: важен ли порядок добавления пар «ключ-зна­
чение~?

Важно ли, какую запись вы будете использовать, такую:

graph["claire"] = [ "thom", "jonny"]
graph["anuj"] = []

или такую:

graph["anuj"] = []
graph["claire"] = [ "thom", "jonny"]

Вспомните предыдущую главу. Ответ: нет, не важно. В хеш-таблицах эле­
менты не упорядочены, поэтому добавлять пары «ключ-значение~ можно
в любом порядке.

У Ануджа, Пегги, Тома и Джонни соседей нет. Линии со стрелками ука­
зывают на них, но не существует стрелок от них к другим узлам. Такой
граф называется направленным - отношения действуют только в одну
сторону.

Итак, Анудж является соседом Боба, но Боб не является соседом
Ануджа. В ненаправленном графе стрелок нет, и каждый из узлов являет­
ся соседом по отношению друг к другу. Например, оба следующих графа
эквивалентны.

типа ross -> rachel и наоборот rachel -> ross образуется некий круговорот
или ross -> rachel только одна стрелка

стр 140 рисунок

Реализация Поиска в ширину рисунок стр 141

1 Создать очередь с именами проверяемых людей
2 извлечь из очереди очередного человека
3 проверить является ли этот человек продавцом манго
4 а) да завершить б) нет добавить всех соседей этого человека в очередь
5 цикл! все заново
6 если очередь пуста в вашей сети нет продавцов манго

В се начинается с создания очереди. В Python для создания двусторонней
очереди (дека) используется функция deque:

from collections import deque
search_queue = deque(); создание очереди
search_queue += graph["you"] все соседи добавляются в очередь поиска

Напомню, что выражение graph ( "you"] вернет список всех ваших соседей,
например ("alice", "ЬоЬ", "claire"]. Все они добавляются в очередь по­
иска.

while search_queue: Пока очередь не пуста ...
    person = search_queue. popleft() из очереди извлекается первый человек
    if person_is_seller(person) Проверяем, является ли этот человек продавцом манго

        print person + " is а mango seller ! " Да, это продавец манго
        return True
    else:
    search_queue += graph[person] Нет, не является. Все друзья этого человека добавляются в очередь поиска
return False Если выполнение дошло до этой строки, значит, в очереди нет продавца манго

И послед нее: н ужно определить функцию person_is_seller, которая со­
общает, является ли челов ек продавцом манго. Например, функция может
выглядеть так:

def person_is_seller(name):
return name[-1] == 'm'

Эта функция проверяет, заканчивается ли имя на букву «m», и если за­
канчивается , этот человек считается продавцом манго. Проверка довольно
глупая , но для нашего примера сойдет. А теперь посмотрим, как работает
поиск в ширину.

легче посмотреть картинку в стр 143

И так далее . Алгор итм продолжает работать до тех п ор, пока:

не будет найден продавец ман го,

очеред ь не оп устеет ( в этом случае п родавца манго нет ).

У Алисы и Боба есть один общий друг: Пегги. Следовательно, Пегги будет
добавлена в очередь дважды: при добавлении друзей Алисы и при добав­
лении друзей Боба. В результате Пегги появится в очереди поиска в двух
экземплярах.

Но проверить, является ли Пегги продавцом манго, достаточно всего один
раз. Проверяя ее дважды, вы выполняете лишнюю, ненужную работу. Сле­
довательно , после проверки человека нужно пометить как проверенного ,
чтобы не проверять его снова .

Если этого не сделать, может возникнуть бесконечный цикл. Предположим,
граф выглядит так:

стр 144

В начале ОL1ередь поиска содержит всех ваших соседей.
Теперь вы проверяете Пегги. Она не является продавцом манго , поэтому
все ее соседи добавляются в очередь поиска.
Вы проверяете себя. Вы не являетесь продавцом манго, поэтому все ваши
соседи добавляются в очередь поиска.
И так далее. Возникает бесконечный цию1, потому что очередь поиска будет
поочередно переходить от вас к Пегги.
Прежде чем проверять человека, следует убедиться в том, что он не
был проверен ранее. Для этого мы будем вести список уже проверенных
людей.


А вот окончательная версия кода поиска в ширину, в которой учтено это
обстоятельство:

def search(name):
    search_queue = deque()
    search_queue += graph(name]
    searched = []        Этот массив испопьзуется дпя отспеживания  уже проверенных пюдей
    while search_queue:
        person = search_queue · popleft()  Чеповек проверяется топько в том спучае, если он не проверялся ранее
        if not person in searched:
            if person_is_seller(person):
                print person +" is а mango seller!"
                return True
            else:
                search_queue += graph[person]  Чеповек помечается как уже проверенный
                searched.append(person)
            return False
search("you")

Попробуйте выполнить этот код самостоятельно. Замените функцию
person_is_seller чем-то более содержательным и посмотрите, выведет ли
она то, что вы ожидали.

Время выполнения

Если поиск продавца манго был выполнен по всей сети, значит, вы прошли
по каждому ребру (напомню: ребром называется соединительная линия или
ли ния со стрелкой, ведущая от одного человека к другому). Таким образом,
время выполнения составляет как минимум О( количество ребер).

Также в программе должна храниться очередь поиска. Добавление одно­
го человека в очередь выполняется за постоянное время : О( 1 ) . Выпол ­
нение операции для каждого человека потребует суммарного времени
О(количестволюдей). Поиск в ширину выполняется за время О(количество
людей+ количество ребер), что обычно записывается в форме O(V+E) (V - кол ичество вершин , Е - количество ребер).

Упражнения

Перед вами небольшой граф моего утреннего распорядка

стр 147

Из графа видно, что я завтракаю только после того, как почищу зубы. Таким
образом , узел «Позавтракать~ зависит от узла «Почистить зубы~.

С другой стороны, душ не зависит от чистки зубов, потому что я могу сна­
чала принять душ, а потом почистить зубы. На основании графа можно
сформулировать порядок, в котором я действую утром:

1. Проснуться.
2. Принять душ.
3. Почистить зубы.
4. Позавтракать.

Следует заметить, что действие «Принять душ~ может перемещаться в спи­
ске, поэтому следующий список тоже действителен:

1. Проснуться.
2. Почистить зубы.
3. Принять душ.
4. Позавтракать.

Для каждого из следующих трех списков укажите, действителен он
или недействителен.

1 Перед вами небольшой граф моего утреннего распорядка.

Для каждого из следующих трех списков укажите, действителен он
или недействителен.

Ответы: А недействителен; В действителен; С недействителен.

Немного увеличим исходный граф. Постройте действительный список
для ЭТОГО графа.

стр 147
Ответ: 1 - Проснуться;2 - Сделать зарядку;3 - Принять душ;
4 - Почистить зубы; 5 - Одеться; 6 - Упаковать обед; 7 - Позавтракать .

Можно сказать, что этот список в некотором смысле отсортирован. Если
задача А зависит от задачи В, то задача А находится в более поздней по­
зиции списка. Такая сортировка называется топологической ; фактически
она предоставляет способ построения упорядоченного списка на основе
графа. Предположим, вы планируете свадьбу и у вас составлен большой
граф с множеством задач, но вы не знаете, с чего начать.

Проведите топологическую сортировку графа и получите список задач, которы е можно
выполнять одну за другой.

Допустим, имеется генеалогическое древо.

Генеалогическое древо тоже граф, потому что в нем есть узлы (люди)
и ребра. Ребра указывают на родителей человека. Естественно, все ребра
направлены вниз в генеалогическом дереве ребро, указывающее вверх,
не имеет смысла. Ведь ваш отец никак не может быть дедушкой вашего
дедушки!

Такая особая разновидность графа, в которой нет ребер, указывающих в об­
ратном направлении, называется деревом.

Такая особая разновидность графа, в которой нет ребер, указывающих в об­
ратном направлении, называется деревом.

стр 149

Упражнение
Какие из следующих графов также являются деревьями?
A C это перевернутое дерево

Шпаргалка

Поиск в ширину позволяет определить, существует ли путь из А в В.

Если путь существует, то поиск в ширину находит кратчайший путь.

Если в вашей задаче требуется найти «кратчайшее Х», попробуйте смо­
делировать свою задачу графом и воспользуйтесь поиском в ширину
для ее решения.

В направленном графе есть стрелки, а отношения действуют в направле­
нии стрелки (Рама-+ Адит означает «Рама должен Адиту» ).

В ненаправленных графах стрелок нет, а отношение идет в обе сторон·ы
(Росс - Рэйчел означает «Росс встречается с Рэйчел, а Рэйчел встреча­
ется с Россом».)

Очереди относятся к категории FIFO первым вошел, первым вышел»).

Стек относится к категории LIFO «последним пришел, первым вышел»

Людей следует проверять в порядке их
добавления в список поиска, поэтому
список поиска должен быть оформлен
в виде очереди, иначе найденный путь
не будет кратчайшим.

Позаботьтесь о том, чтобы уже прове­
ренный человек не проверялся заново,
иначе может возникнуть бесконечный
цикл .












