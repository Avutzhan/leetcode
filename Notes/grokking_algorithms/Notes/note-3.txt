**********************Рекурсия*************************

Пример с чемоданом

Допустим, вы разбираете чулан своей бабушки и натыкаетесь на загадочный
запертый чемодан.
Бабушка говорит, что ключ к чемодану, скорее всего, лежит в коробке .
В коробке лежат другие коробки, а в них лежат маленькие коробочки. Ключ
находится где-то там. Какой алгоритм поиска ключа предложите вы? По­
думайте над алгоритмом, прежде чем продолжить чтение.

1 Сложить все коробки в кучу
2 Взять коробку и открыть
3 Если внутри лежит коробка добавить ее в кучу для последующего поиска
4 Если внутри лежит ключ поиск закончен
5 Повторить

можно посторить на цикле
Какое решение кажется вам более простым? Первое решение можно постро­
ить на цикле while. Пока куча коробок не пуста, взять очередную коробку
и проверить ее содержимое :

есть второй способ

1 Посмотерть содержимое коробки
2 Если вы найдете коробку вернуться к шагу 1
3 Если вы найдете ключ поиск завершен

а это решение делается на рекурсии
Рекурсией называется вызов функцией
самой себя.

Оба решения делают одно и то же, но второе решение кажется мне более
понятным и локаничным певрвое какое то трудное и длинное

Рекурсия применяется тогда, когда решение становится более
понятным. Применение рекурсии не ускоряет работу программы: более
того, решение с циклами иногда работает быстрее. Мне нравится одна ци­
тата Ли Колдуэлла с сайта Stack Overlow: циклы могут ускорить работу
программы . Рекурсия может ускорить работу программиста. Выбирайте,
что важнее в вашей ситуации!

Рекурсия используется во многих нужных алгоритмах, поэтому важно по­
нимать эту концепцию .

Базовый случай и рекурсивный случай

так как функция вызывает саму себя можно легко написать функцию которая вызывается бесконечно
нужно писать в какой момент следует прервать функцию
вот почему каждая рекурсивная функция состоит из двух частей базового и рекурсивного случая
в рекурсивном случае функция вызывает сама себя
в базовом случае функция себя не вызывает чтобы предотвратить зацикливание

пример бесконечного кода
def countdown(i):
print i
countdow n(i-1)

пример с базовым случаем
def countdown(i):
print i
if i <= 0       //если i меньше или равно 0 то работа закончена
    return
else            //если i больше 0 значит опять вызываем себя только минус 1
    countdow n(i-1)

********************Стек****************************

Стек - простая структура данных.
stack first in last out
ставка в начало вывод из конца

Во внутренней работе вашего компьютера используется стек, называемый
стеком вызовов.

def greet(name):
    print "hello, " + name + "!"
    greet(name)
    print "getting ready to say bye..."
    bye()

def greet2(name):
    print "how are you, " + name + "?"
def bye():
    print "ok bye"!

что происходит при вызове функции greet('maggie')
Сначала ваш компьютер выделяет блок памяти для этого вызова функции.
___________________
|                  |
|                  |
|__________________|

пустой блок памяти

Затем эта память используется. Переменной name присваивается значение
"maggie"; оно должно быть сохранено в памяти.

записываем в этот блок данные
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Каждый раз , когда вы вызываете функцию , компьютер сохраняет в памяти
значения всех переменных для этого вызова.

Далее выводится приветствие hello, maggie ! , после чего
следует второй вызов greet2( "maggie" ). И снова
компьютер выделяет блок памяти для вызова функции.

___________________
|    greet2        |
--------------------
| name:  | maggie  |    <----- текущий вызов функции
|________|_________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Ваш компьютер объединяет эти блоки в стек. Второй блок создается над первым.

Вы выводите сообщение how are you, maggie?, после чего воз­
вращаете управление из вызова функции. Когда это происходит, блок на
вершине стека извлекается из него .

___________________
|    greet2        |
--------------------
| name:  | maggie  |    <----- текущий вызов функции который уже отработал и мы его удаляем
|________|_________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Теперь верхний блок в стеке относится к функции greet; это означает, что
вы вернулись к функции greet.

При вызове функции greet2 функция greet еще не была завершена.

Здесь-то и скрывается истинный смысл этого раздела: когда вы вызываете
функцию из другой функции, вызывающая функция приостанавливается в частично завершеноом состоянии.
Все значения переменных этой функции остаются в памяти.
А когда выполнение функции greet2 будет завершено, вы вернетесь к функции greet и продолжите ее
выполнение с того места, где оно прервалось.

Сначала выводится сообщение getting ready to say Ьуе ... , после чего вызывается функция Ьуе.
___________________
|       BYE        |
|                  |    <----- текущий вызов функции
|__________________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Блок для этой функции добавляется на вершину стека. Далее выводится
сообщение ok Ьуе ! с выходом из вызова функции.

___________________
|       BYE        |
|                  |    <----- текущий вызов функции уже отработал и мы его удаляем
|__________________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Управление снова возвращается функции greet. Делать больше нечего, так
что управление возвращается и из функции greet. Этот стек, в котором со­
хранялись переменные разных функций, называется стеком вызовов.

упражнение

что можно сказать об этом стеке
___________________
|    greet2        |
--------------------
| name:  | maggie  |    <----- текущий вызов функции
|________|_________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Ответ: Некоторые наблюдения , о которых вы могли бы упомянуть:

1 сначала вызывается функция greet для переменной name = maggie
2 затем функция greet вызывает функцию greet2 для переменной name = maggie
3 на этой стадии функция greet находится в незавершенном, приостановленном состоянии;
4 текущим вызовом функции является вызов greet2
5 после завершения этого вызова функция greet продолжит выполнение.

А теперь посмотрим , как работает стек вызовов с рекурсивными функ­
циями.

в примере факториала

!5 = 5*4*3*2*1 = 120

def fact(x):
    if x == 1:
        return 1
    else:
        return x * fact(x-1)

например мы вызвали fact(3)

код                     стек вызовов
fact(3)                 fact x = 3          первый вызов
if x == 1               fact x = 3
else                    fact x = 3
return x * fact(x -1)   fact x = 2, fact x = 3      рекурсивный вызов
if x == 1               fact x = 2, fact x = 3      текущий вызов первый fact x = 2
else                    fact x = 2, fact x = 3      одна и та же переменная но разные значения
return x * fact(x -1)   fact x = 1, fact x = 2, fact x = 3 обратится к другому значению во время вызова не возможно
if x == 1               fact x = 1, fact x = 2, fact x = 3

это третий вызов и пока ни один вызов не завершился

fact x = 1, первый блок который будет извлечен из стека этот вызов вернет управление и мы его удаляем возвращает 1
fact x = 2,
fact x = 3

fact x = 2,    возвращает 2 return x * fact (x - 1) вызов только что вернувший управление тут x равно 2 эту переменную удаляем
fact x = 3
                                    3         2
fact x = 3      возвращает 6 return x * fact (x - 1) вызов только что вернувший управление

Здесь важно, что каждый вызов создает собственную копию х. Обратиться
к переменной х , принадлежащей другой функции, невозможно.
Стек играет важную роль в рекурсии. В начальном примере были представ­
лены два решения поиска ключа. Вспомните, как выглядел первый:

1 Сложить все коробки в кучу
2 Взять коробку и открыть
3 Если внутри лежит коробка добавить ее в кучу для последующего поиска
4 Если внутри лежит ключ поиск закончен
5 Повторить

В этом случае все коробки лежат в одном месте и вы всегда знаете, в каких
коробках еще нужно искать ключ.

Но в рекурсивном решении никакой кучи не существует.

1 Посмотерть содержимое коробки
2 Если вы найдете коробку вернуться к шагу 1
3 Если вы найдете ключ поиск завершен

Если кучи нет, то как ваш алгоритм узнает, в каких коробках еще нужно
искать? Пример:
1 проверяем коробку A внутри есть коробки B и C
2 проверяем коробку B в ней лежит коробка D
3 проверяем коробку D она пуста

К этому моменту стек вызовов выглядит примерно так:

box D -
box B -
box A C

коробки которые мы проверяем записываются в стек вызовов
куча коробок хранится в стеке!

Это стек незавершенных вызовов функ­
ции, каждый из которых ведет собственный незаконченный список коробок
для поиска. Стек в данном случае особенно удобен, потому что вам не нуж­
но отслеживать коробки самостоятельно стек делает это за вас.

Стек удобен, но у него есть своя цена: сохранение всей промежуточной
информации может привести к значительным затратам памяти. Каждый
вызов функции занимает не много памяти, но если стек станет слишком
высоким, это будет означать, что ваш компьютер сохраняет информацию
по очень многим вызовам. На этой стадии есть два варианта:

1 Переписать код с использованием цикла.

2 Иногда можно воспользоваться так называемой хвостовой рекурсией.
Это непростая тема, которая выходит за рамки книги. Вдобавок она под­
держивается далеко не во всех языках .

упражнение

Предположим, вы случайно написали рекурсивную функцию, которая
бесконечно вызывает саму себя. Как вы уже видели , компьютер вы­
деляет память в стеке при каждом вызове функции. А что произойдет
со стеком при бесконечном выполнении рекурсии?

Ответ: Стек будет расти бесконечно . Каждой программе выделяется
ограниченный объем памяти в стеке. Когда все пространство будет
исчерпано (а рано или поздно это произойдет) , программа завершится
с ошибкой переполнения стека .

Шпаргалка

Когда функция вызывает саму себя, это
называется рекурсией.

В каждой рекурсивной функции должно
быть два случая: базовый и рекурсивный .

Стек поддерживает две операции: зане ­
сение и извлечение элементов.

Все вызовы функций сохраняются в сте­
ке вызовов.

Если стек вызовов станет очень большим, он займет слишком много
памяти.

