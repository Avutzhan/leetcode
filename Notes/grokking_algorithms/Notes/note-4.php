Узнаем о стратегии разделяй и властвуй

Мы исследуем принцип ~разделяй и властвуй>,>, хорошо известный рекурсивный метод
решения задач.

Этот алгоритм сортировки работает на­
много быстрее сортировки выбором

Пример стратегии разделяй и властвуй
Представьте, что вы фермер, владеющий земельным участком.

Вы хотите равномерно разделить землю на одинаковые квадратные участ­
ки. Участки должны быть настолько большими, насколько это возможно,
так что ни одно из следующих решений не подойдет.

не квадратное, слишком маленькие, все участки должны быть одинаковыми

Как определить наибольший размер квадрата для участка? Воспользуйтесь
стратегией «разделяй и властвуй~! Алгоритмы на базе этой стратегии яв­
ляются рекурсивными.

Решение задачи методом «разделяй и властвуй ~ состоит из двух шагов:

1 Сначала определяется базовый случай. Это должен быть простейший
случай из всех возможных.
2 Задача делится или сокращается до тех пор, пока не будет сведена к ба­
зовому случаю .

А теперь воспользуемся стратегией «разделяй и властвуй~ для поиска ре­
шения этой задачи. Каков самый большой размер квадрата, который может
использоваться?

Для начала нужно определить базовый случай. Самая простая ситуация
-
если длина одной стороны кратна длине другой стороны .

Предположим , длина одной стороны составляет 25 м,
а длина другой 50 м В этом случае размер самого большого участка составляет 25 м х 25 м
и надел после деления будет состоять из двух участков

Теперь нужно вычислить рекурсивный случай. Здесь-то вам на помощь
и приходит стратегия «разделяй и властвуй ~ .

В соответствии с ней при каждом рекурсивном вызове задача должна сокращаться. Как сократить
эту задачу? Для начала разметим самые большие участки, которые можно использовать.

В исходном наделе можно разместить два участка 640 х 640,  и еще останется место. Тут-то и наступает момент истины .
Нераспределенный остаток - это тоже надел земли, который нужно разделить. Так почему бы не применить
к нему тот же алгоритм?

Итак, мы начали с надела 1680 х 640, который необходимо разделить на
участки. Но теперь разделить нужно меньший сегмент 640 х 400

Если вы найдете самый большой участок, подходящий для этого размера, это
будет самый большой участок, подходящий для всей фермы. Мы только
что сократили задачу с размера 1680 х 640 х до 640 х 400

Алгоритм Евклида если вы найдете самый болшой участок подходящий для этого размера
это будет самый большой участок подходящий для всей фермы

Применим тот же алгоритм снова. Если начать
с участка 640 х 400 то размеры самого большого квадрата
который можно создать, составляют 400 х 400

Остается меньший сегмент с размерами 400 х 240

Отсекая поделенную часть, мы приходим к еще меньшему размеру сегмента, 240 х 160

После очередного отсечения получается еще меньший сегмент.

Эге, да мы пришли к базовому случаю: 160 кратно 80

Если разбить этот
сегмент на квадраты, ничего лишнего не останется! 80 х 80

Итак, для исходного надела земли самый большой размер участка будет
равен 80 х 80

Вспомните, как работает стратегия ~разделяй и властвуй•:

1 Определите простейший случай как базовый.

2 Придумайте, как свести задачу к базовому случаю.

«Разделяй и властвуй~ не простой алгоритм, который можно применить
для решения задачи. Скорее, это подход к решению задачи. Рассмотрим
еще один пример.

Нужно просуммировать все числа и вернуть сумму. Сделать это в цикле
совсем не сложно:

второй пример

def sum(arr)
    total = 0
    fro x in arr:
        total += x
    return total

print sum([1, 2, 3, 4])

Но как сделать то же самое с использованием рекурсивной функции?

Шаг 1
определить базовый случай. Как выглядит самый простой массив,
который вы можете получить? Подумайте, как должен выглядеть про­
стейший случай, и продолжайте читать. Если у вас будет массив с О или
1 элементом, он суммируется достаточно просто.

[ ] базовый случай 0 элементов = сумма равна 0
[7] 1 элемент = сумма равна 7

Итак, с базовым случаем мы определились.

Шаг 2
каждый рекурсивный
вызов должен приближать вас к пустому мас­
сиву. Как уменьшить размер задачи? Один из возможных способов:

sum([2, 4, 6]) = 12

2 + sum([4, 6]) = 2 + 10 = 12

В любом случае результат равен 12  Но во второй версии функции sum
передается меньший массив. А это означает, что вы сократил и размер своей
задачи!

Функция sum может работать
по следующей схеме:

получить список

если пусть вернуть 0

в противном случае результат равен сумме первого числа в списке и суммы остального списка

А вот как это выглядит в действии.

sum ([2, 4, 6]) 12
2 + sum([4, 6]) 2 +10 = 12
4 + sum([6]) 4 + 6 = 10
базовый случай
sum([6]) = 6

Когда вы пишете рекурсивную функцию, в которой задействован массив, ба­
зовым случаем часто оказывается пустой массив или массив из одного эле­
мента. Если вы не знаете, с чего начать, - начните с этого.

Зачем применять рекурсию, если задача легко решается с циклом?
Вполне резонный вопрос. Что ж, пора познакомиться с функцио­
нальным программированием!

В языках функционального программирования, таких как Haskell ,
циклов нет, поэтому для написания подобных функций приходит­
ся применять рекурсию.

sum [] = 0 базовый
sum (x:xs) = x + (sum xs) рекурсивный случай

На первый взгляд кажется, что одна функция имеет два определе­
ния. Первое определение выполняется для базового случая, а вто­
рое  - для рекурсивного случая .

Функцию также
Haskell с использованием команды if
sum arr = if arr == []
            then 0
            else (head arr) + (sum (tail arr))

Но первое определение проще читается. Так как рекурсия широко
применяется в языке haskell
в него включены всевозможные удоб­
ства для ее использования. Если вам нравится рекурсия или вы хо­
тите изучить новый язык присмотритесь к haskell

упражнения

Напишите код для функции sum

def sum(list):
    if list == [] :
        return 0
    return list[0] + sum(list[1:])


Напишите рекурсивную функцию для подсчета элементов в списке.

def count(list):
    if list == [] :
        return 0
    return 1 + count(list[1:])

Найдите наибольшее число в списке.

def max(list):
    if len(list) == 2:
        return list[0] if list[0] > list[1] else list[1]
    sub_max = max(list[1:])
    return list[0) if list[0] > sub_max else sub_max

Помните бинарный поиск из главы 1? Он тоже относится к классу ал­
горитмов ~разделяй и властвуй~. Сможете ли вы определить базовый
и рекурсивный случай для бинарного поиска?


Ответ: Базовым случаем для бинарного поиска является массив,
содержащий всего один элемент. Если искомый элемент совпадает
с элементом массива  вы нашли его
В противном случае элемент
в массиве отсутствует.

В рекурсивном случае для бинарного поиска массив делится пополам,
одна половина отбрасывается, а для другой половины проводится
бинарный поиск.


Воспользуемся быстрой сортировкой для упорядо­
чения массива. Как выглядит самый простой массив,
с которым может справиться алгоритм сортировки
(помните подсказку из предыдущего раздела)? Не­
которые массивы вообще не нуждаются в сорти­
ровке.

самый простой массив это пустой или с одним элементом
такие массивы не нужно сортировать

Пустые массивы и массивы, содержащие всего один элемент, станут базо­
вым случаем. Такие массивы можно просто возвращать в исходном виде
- сортировать ничего не нужно:

def quick sor t(array):
    if len(array) < 2:
        return array

Теперь перейдем к массивам большего размера. Массив из двух элементов
тоже сортируется без особых проблем.

[1, 7] сравниваем два элемента если первый элемент меньше второго меняем их местами

А как насчет массива из трех элементов?

Помните: мы используем стратегию «разделяй и властвуй» . Следователь­
но, массив должен разделяться до тех пор, пока мы не придем к базовому
случаю. Алгоритм быстрой сортировки работает так: сначала в массиве
выбирается элемент, который называется опорным.

О том, как выбрать хороший опорный элемент, будет рассказано далее.
А пока предположим, что опорным становится первый элемент массива.

Теперь мы находим элементы, меньшие опорного, и элементы, большие
опорного.

например опорный элемент 33
в массиве

15 10 меньще 33 числа больше нет значит пустой массив

Этот процесс называется разделением. Теперь у вас имеются :

1 подмассив всех элементов, меньших опорного;

2 опорный элемент;

3 подмассив всех элементов, больших опорного.

Два подмассива не отсортированы они просто выделены из исходного
массива. Но если бы они бъuiu отсортированы, то провести сортировку всего
массива было бы несложно.

10 15 33 []

Если бы подмассивы были отсортированы, то их можно было бы объеди­
нить в порядке ~левый подмассив опорный элемент правый подмассив» и получить отсортированный массив .

В нашем примере получается
[ 10, 15] + [ 33] + [] = [ 10, 15, 33],
то есть отсортированный массив.

Как отсортировать подмассивы? Базовый случай быстрой сортировки
уже знает, как сортировать массивы из двух элементов (левый подмассив)
и пустые массивы (правый подмассив). Следовательно, если применить
алгоритм быстрой сортировки к двум подмассивам, а затем объединить
результаты, получится отсортированный массив!

quicksort([lS, 10]) + [33) + quicksort([])
> [ 10, 15, 33]

Этот метод работает при любом опорном элементе. Допустим, вместо 33
в качестве опорного был выбран элемент 15.

10 15 33

Оба подмассива состоят из одного элемента, а вы уже умеете сортировать
такие подмассивы. Получается, что вы умеете сортировать массивы из трех
элементов. Это делается так:

1 Выбрать опорный элемент.
2 Разделить массив на два подмассива: элементы, меньшие опорного,
и элементы, большие опорного.
3 Рекурсивно применить быструю сортировку к двум подмассивам.

Как насчет массива из четырех элементов?

33 10 15 7

Предположим, опорным снова выбирается элемен 33

Левый подмассив состоит из трех элементов. Вы уже знаете, как сортирует­
ся массив из трех элементов: нужно рекурсивно применить к нему быструю
сортировку.

[10 15 7] 33 []

[7] 10 [15]

Следовательно, вы можете отсортировать массив из четырех элементов.
А если вы можете отсортировать массив из четырех элементов, то вы так­
же можете отсортировать массив из пяти элементов. Почему? Допустим,
имеется массив из пяти элементов.

3 5 2 1 4

Вот как выглядят все варианты разделения этого массива в зависимости от
выбранного опорного элемента:

[] 1 [3 2 5 4]
[1] 2 [3 5 4]
[2 1] 3 [5 4]
[3 2 1] 4 [5]
[3 2 1 4] 5 []

Все эти подмассивы содержат от О до 4 элементов.
А вы уже знаете , как отсортировать массив, содержащий от О до 4 элементов.
с использованием быстрой сортировки! Таким образом, независимо от выбора опорного
элемента вы можете рекурсивно вызывать быструю сортировку для двух
подмассивов .

Например, предположим, что в качестве опорного выбирается элемент 3. Вы применяете быструю сортировку к подмассивам.

Подмассивы отсортированы, и теперь из них можно собрать отсортирован­
ный массив. Решение работает даже в том случае, если выбрать в качестве
опорного элемент 5:

Итак, решение работает независимо от выбора опорного элемента. Следо­
вательно, вы можете отсортировать массив из пяти элементов. По той же
логике вы можете отсортировать массив из шести элементов и т. д.

Доказательство по индукции

Оно состоит из двух частей базового случая и индукционного перехода

например нуно доказать что я могу подняться на верх стремянки
елси мои ноги стоят на ступеньке то я могу переставить их на следующую ступеньку - это индукционный переход
Таким образом если я стою на ступеньке 2 то могу подняться на ступеньку 3
что касается базового случая я стою на ступеньке 1
из этого следует что я могу подняться на самый верх стремянки каждый раз поднимаясь на одну ступеньку

Аналогичные рассуждения применимы к быстрой сортировке
Работоспособность алгоритма для базового случая массивов с размером 0 и 1 была продемонстрирована
В индукционном переходе я показал что если быстрая сортировка работает для саммива с 1 элементом
то она будет работать для массива из 2 элементов а если работает с 2 то будет и с 3 и так далее
Из этого следует что быстрая сортировка будет работать для всех массивов любого размера.

А вот как выглядит программный код быстрой сортировки:

def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]

        greater = [i for i in array[1:] if i > pivot]

        return quicksort(less) + [pivot] + quicksort(greater)

print quicksort([10, 5, 2, 3])

Снова об большом О

            бинарный       простой       быстрая             сортировка         задача о
            поиск          поиск         сортировка          выбором            коммивояжере
                                                                2
            O(log n)       O(n)          O(n log n)          O(n )              O(n!)
10          0.3 s          1 s           3.3 s               10 s               4.2 days
100         0.6 s          10 s          66.4 s              16.6 min           2.9 x 10 v stepeni 144 years
1000        1s             100 s         998 s               27.7 hours         1.27 x 10 v stepeni 2559 years

Возьмем алгоритм сортировки выбором, и это довольно медленный алгоритм.
так называемая сортировка слиянием O(n log n) Намного быстрее!
С быстрой сортировкой дело обстоит сложнее.
                                                        2
В худшем случае быстрая сортировка работает за время O(n )
Ничуть не лучше сортировки выбором!
Но это худший случай, а в среднем быстрая сортировка выполняется за время O(n log n)
что в данном случае понимается под ~худшим~ и ~средним~ случаем?
если быстрая сортировка в среднем выполняется за время O(n log n)
а сортировка слиянием выполняется за время O(n log n)
всегда, то по­
чему бы не использовать сортировку слиянием? Разве она не быстрее?

Сортировка слиянием и быстрая сортировка

Допустим, у вас имеется простая функция для вывода каждого элемента
в списке:

def print_items(list):
    for item in list:
        print item

Эта функция последовательно перебирает все элементы списка и выво­
дит их. Так как функция перебирает весь список, она выполняется за вре­
мя O(n)

Теперь предположим, что вы изменили эту функцию и она делает
секундную паузу перед выводом:

from time import sleep
def print_items2(list):
    for item in list:
        sleep(1)
        print item

Перед вьrводом элемента функция делает паузу продолжительностью
в
1 секунду.
Предположим, вы выводите список из пяти элементов с ис­
пользованием обеих функций:

Обе функции проходят по списку один раз, и обе выполняются за вре­
мя O(n)

Как вы думаете, какая из них работает быстрее? Я думаю, print_items
работает намного быстрее, потому что она не делает паузу перед вы­
водом каждого элемента. Следовательно, даже при том, что обе функции
имеют одинаковую скорость

О большое O(n) в действительности это означает следующее:
C * n
C - фиксированный промежуток времени называется контстантой
Обычно константа игнорируется, потому что если два алгоритма имеют
разное время «О-большое~, она роли не играет.

Для примера возьмем бинарный и простой поиск. Допустим, такие константы присутствуют в обоих
алгоритмах.

простой поиск 10мс * n

бинарный поиск 1с * log n

Первая реакция: ~ого! У простого поиска константа равна
10 миллисекундам, а у бинарного поиска
- 1 секунда.Простой поиск намного быстрее!~

Теперь предположим, что поиск ведется по списку из
4 миллиардов элементов. Время будет таким:

простой поиск 10мс * 4 миллиарда = 463 дня

бинарный поиск 1с * 32 = 32 секунды

Как видите, бинарный поиск все равно работает намного быстрее. Констан­
та ни на что не повлияла.

Однако в некоторых случаях константа может иметь значение. Один из
примеров такого рода
- быстрая сортировка и сортировка слиянием.

У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому,
несмотря на то Что оба алгоритма характеризуются временем O(log n)

быстрая сортировка работает быстрее. А на практике быстрая сортировка
работает быстрее, потому что средний случай встречается намного чаще
худшего.

А теперь ответим на первый вопрос: как выглядит средний случай по срав­
нению с худшим?

Средний и худший случай
Быстродействие быстрой сортировки сильно зависит от выбора опорного
элемента.

Предположим, опорным всегда выбирается первый элемент, а бы­
страя сортировка применяется к уже отсортированному массиву. Быстрая
сортировка не проверяет, отсортирован входной массив или нет, и все равно
пытается его отсортировать.

например массив из 8 элементов будет постоянно выбирать порным элементов первый элемент
и таким образом стек вызовов будет иметь 8 элементов

[1,2,3,4,5,6,7,8]
[] <1> [,2,3,4,5,6,7,8]
[] <2> [3,4,5,6,7,8]
[] <3> [4,5,6,7,8]
[] <4> [5,6,7,8]
[] <5> [6,7,8]
[] <6> [7,8]
[] <7> [8]

Обратите внимание: на этот раз массив не разделяется на две половины .
Вместо этого один из двух подмассивов всегда пуст, так что стек вызовов
получается очень длинным.
Теперь предположим, что в качестве опорного
всегда выбирается средний элемент. Посмотрим, как выглядит стек вызовов
в этом случае. Размер стека вызово 4

[1,2,3,4,5,6,7,8]
[1,2,3] <4> [5,6,7,8]
[1] <2> [3]     <6> [7,8]
                [] <7> [8]


Стек намного короче! Массив каждый раз делится надвое, поэтому такое
количество рекурсивных вызовов излишне. Вы быстрее добираетесь до
базового случая, и стек вызовов получается более коротким.

Первый из рассмотренных примеров описывает худший сценарий, а вто­
рой лучший
В худшем случае размер стека описывается как O(n)
В лучшем случае он составит O(log n)

Теперь рассмотрим первый уровень стека. Один элемент выбирается опор­
ным, а остальные элементы делятся на подмассивы. Вы перебираете все
восемь элементов массива, поэтому первая операция выполняется за вре­
мя O(n)

На этом уровне стека вызовов вы обратились ко всем восьми
элементам. Но на самом деле вы обращаетесь к O(n) элементам на каждом
уровне стека вызовов!

[1,2,3,4,5,6,7,8]
[] <1> [,2,3,4,5,6,7,8]
[] <2> [3,4,5,6,7,8]
[] <3> [4,5,6,7,8]
[] <4> [5,6,7,8]
[] <5> [6,7,8]
[] <6> [7,8]
[] <7> [8]

Даже если массив будет разделен другим способом, вы все равно каждый
раз обращаетесь к О( п) элементам.

[1,2,3,4,5,6,7,8]
[1,2,3] <4> [5,6,7,8]
[1] <2> [3]     <6> [7,8]
[] <7> [8]

тут тоже каждый стек имеет время О( п)
Итак, завершение каждого уровня требует времени О(п).
но количество уровней будет O(log n)

В этом примере существуют  O(log n) (с технической точки зрения пра­
вильнее сказать «высота стека вызовов равна O(log n)) уровней.
А так как каждый уровень занимает время О(п), то весь алгоритм займет время
О( п) * O(log n) = O(n log n). Это сценарий лучшего случая.

В худшем случае существуют О(п) уровней, поэтому алгоритм займет время
                2
О(п)* О(п) = О(п ) .

А теперь сюрприз: лучший случай также является средним . Если вы всегда
будете выбирать опорным элементом случайный элемент в массиве, бы­
страя сортировка в среднем завершится за время О(п log п). Это один из
самых быстрых существующих алгоритмов сортировки, который заодно
является хорошим примером стратегии «разделяй и властвуй».

Упражнения
1 Вывод значения каждого элемента массива.
O(n)
2 Удвоение значения каждого элемента массива.
O(n)
3 Удвоение значения только первого элемента массива.
O(1)
4 Создание таблицы умножения для всех элементов массива. Например,
если массив состоит из элементов [2,3,7,8,10] сначала каждый эле­
мент умножается на 2 затем каждый элемент умножается на 3 затем на 7 и тд
   2
O(n )

Шпаргалка

Стратегия разделяй и властвуй основана на разбиении задачи на уменьшающиеся фрагменты
Если вы используете стратегию разделяй и властвуй со списком то базовым случаем скорее всего
является пустой массив или массив из одного элемента

Если вы реализуете алгоритм быстрой сортировки, выберите в качестве
опорного случайный элемент. Среднее время выполнения быстрой сор­
тировки составляет О(п log п)!

Константы в «О-большом» иногда могут иметь значение . Именно по
этой причине быстрая сортировка быстрее сортировки слиянием.

При сравнении простой сортировки с бинарной константа почти никогда
роли не играет, потому что O(log п) слишком сильно превосходит О(п)
по скорости при большом размере списка.



