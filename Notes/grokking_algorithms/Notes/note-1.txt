* Повторить базовую алгебру стр 20
* Знать хотя бы один язык программирования

Бинарный поиск - это алгоритм, на входе он получает отсортированный спикос элементов
обязательно отсортированный. Если элемент который вы ищете присутствует в списке то
бинарный поиск возвращает ту позицию индекс массива в которой он был найдет. В противном случает бинарный
поиск вернет null.

чтобы найти какое то число в массиве от 1 до 100 в линейном поиске мы должны сделать 100 попыток
а вот в бинарном поиске нам потребуется всего 7 попыток
потому что при бинарном поиске каждый раз исключается половина чисел
100 = 50, 25, 13, 7, 4, 2, 1
например загадал 57.
надо говорить больше или меньше загаданного числа.
начинаем с 50.
50 меньше 57 значит
все числа до 50 исключаем
остается от 50 до 100.
попытка 2 это число 75.
75 больше 57 значит
от 75 до 100 исключаем.
остается от 50 до 75.
попытка 3 середина будет 63. 63 больше 57 значит
остается от 50 до 63 и так далее пока не найдем то число

получается список из 100 элементов потребует 7 шагов
список из 240 000 элементов потребует 18 шагов

240 = 120, 60, 30, 15, 7.5, 3750, 1875, 938, 469, 235, 118, 59, 30, 15, 8, 4, 2, 1
18 шагов

* В общем для списка из n элементов бинарный поиск выполняется за log n шагов, тогда как
                                                                     2
  простой поиск будет выполнен за n шагов

* Логарифмы операция обратная возведению в степень

* Возведение в степень например
      2
  1) 2  = 8 ,2 нужно умножить 2 раза на саму себя чтобы получить 8
      4
  2) 2  = 16, 2 нужно цмножить 4 раза чтобы получить 16

  отсюда и вывод

  1) log 8 = 3, логарифм 8 равен 3 то есть мы 2 умножаем на саму себя 3 раза чтобы получить 8
        2
  2) log 16 = 4, логарифм 16 равет 4 то есть 2 умножаем на саму себя 4 раза чтобы получить 16
        2

  получается log  100 означает сколько раз нужно умножить 10 на саму себя чтобы получить 10 ответ 2
                10

* log всегда означает log
                         2
Когда мы ищем элемент с применением простого поиска в худшем случае нам придется проверять каждый элемент
из списка 8 чисел понадобится не больше 8 попыток
Для бинарного поиска в худшем случае потребуется не более log n проверок. Если есть список 8 элементов
                                                             2
это можно обозначить так log 8 или просто log 8 сколько действий нужно совершить чтобы получить результат 8 равно 3 действия
                            2
вот таким образом можно вычислять количество попыток в бинарном поиске
                                                        10
Для списка из 1024 элементов log 1024 = 10, потому что 2   == 1024
                                2
следовательно из списка 1024 элементов проверка будет 10 попыток.

* Бинарный поиск работает только с отсортированными по порядку элементами
* В примере будем использовать массив
и так пример в отдельном файле тут в папке

упражнение 1
                                                      7
Для списка из 128 элементов log 128 = 7, потому что 2   == 128
                               2
ответ 7

упражнение 2

128 увеличилось на 2 = 256. log 256 = 8, потому что 2 в 8 степени == 256

стр 29

Время выполнения

O(n) линейное время
* Линейное время выполнения алгоритма это когда из списка 100 чисел мы проверям каждле число
таким образом получается сколько элементов списке столько и проверок если в списке 4 миллиарда
элементов то мы выполним 4 миллиарда проверок

O(Log n) логарифмическое время
В бинарном поиске все по другому если список состоит из 100 элементов то попыток булет 7
если же 4 миллиарда элементов то попыток будет не больше 32
* это и есть логарифмическое время

стр 29

время выполнения алгоритмов растет с разной скоростью

например простой поиск из 100, 10 000, 1 000 000 будет занимать время
100 мс, 10 секунл, 11 дней
а бинарный поиск будет занимать 7 мс, 14 мс, 32 мс

то есть с увеличением количества элементов простой будет сильно замедляться а бинарный сильно ускоряться

Вот почему не достаточно знать сколько времени должен работать алгоритм
а нужно знать как возрастает время выполнения с востом размера списка

тут пригодится О большое оно описывает насколько быстро работает алгоритм

О(n) = n количество операций для выполнения алгоритма. Оно указывает насколько быстро возрастает время выполнения
алгоритма

О большое определяет время выполнения в худшем случае

то есть в худшем случае нам придется выполнить n количесво операций
чтобы завершить алгоритм.

например есть телефонная книга там мы ищем имя на букву А а она стоит на первом месте
алгоритм все равно отработает O(n) время просто даже если вы найдете имя с первой попытки
найти с первой попытки это лучший возможный случай а мы рассматриваем о большое то есть
худший возможный случай

то есть в худшем случае мы посмотрим на каждое имя в телефонной книге по одному разу
это дает нам гарантии что простой поиск никогда не будет работать медленнее O(n)

5 разновидностей о большого часто встречаются в порядке убывания скорости

O(log n) логарифмическое время бинарный поиск
O(n) линейное время простой поиск
O(n * log n) эффективные алгоритмы сортировки быстрая сортировка
   2
O(n ) н в степени 2. медленные алгоритмы сортировки сортировка выбором
O(n!) очень медленные алгоритмы задача о коммивояжере называется n-factorial

примеры
                                           2
    O(log n)    O(n)    O(n * log n)    O(n )   O(n!)
16      0.4s    1.6s    6.4s            25.6s   66301 years
                                                      548
256     0.8s    25.6s   3.4min          1.8h    8.6*10   years
                                                      2638
1024    1.0s    1.7s    17min           1.2d    5.4*10    years


* Скорость алгоритмов измеряется не в секундах, а в темпе роста количе­
  ства операций.

* По сути формула описывает, насколько быстро возрастает время выпол­
  нения алгоритма с увеличением размера входных данных.

* Время выполнения алгоритмов выражается как «О-большое».

* Бремя выполнения O(log п) быстрее О(п), а с увеличением размера спи­
  ска, в котором ищется значение, оно становится намного быстрее.

Упражнение 1
Известна фамилия нужно найти номер в телефоной книге
ответ
O(log n)

Упражнение 2
Известен номер, нужно найти фамилию в телефонной книге. (Под­
сказка: вам придется провести поиск по всей книге!)
Ответ: О(п).

Упражнение 3
Нужно прочитать номера всех людей в телефонной книге.
Ответ: О(п).

Упражнение 4

Нужно прочитать телефоны всех людей, фамилии которых начинают­
ся с буквы «А». (Вопрос с подвохом! В нем задействованы концепции ,
которые более подробно рассматриваются в главе 4
нужно прочитать ответ

Ответ: О(п).

Возможно, кто-то подумает: «Я делаю это только для
одной из 26 букв а значит, время выполнения должно быть равно
О(п/26).» Запомните простое правило: в «О-большое» игнорируются
числа, задействованные в операциях сложения, вычитания, умно­
жения или деления. Ни одно из следующих значений не является
правильной записью «О-большое»: O (n + - * / 26) все они равны O (n)
Почему по кочану и по капусте да шутка для самого себя
Почему потом что Если вам интересно, найдите раздел «Снова об "О-большом"» в главе 4
и прочитайте о константах в этой записи (константа - это просто число; в этом вопросе 26
является константой)

Задача о коммивояжере

задача с временм выполнения O(n!)

известная задача из области теории вычислений многие ученые предполагают что с этим ничего не поделать

Например есть утка коммивояжер которой нужно проехать 5 городов
но он хочет проехать минимальное общее расстояние
Одно из возможных решений :
нужно перебрать все возможные комбинации порядка объезда городов .

все расстояния суммируются после чего выбирается путь с кратчайшим расстоянием
для 5 городов можно создать 120 перестановок поэтому чтобы решить задачку для 5 городов
потребуется 120 операций
для 6 = 720 операций
для 7 = 5040 операций
для 8 = 40320 операций
для 30 = 202020202002200220202020200202 операций
количество операций стремительно растет

В общем случае для вычисления резу ль тата при п элементах потребуется
п! (п-факториал) операций.

О(п!) называется факториальным временем выполнения

то есть при любом серьезном размере саиска количество операций будет огромным
если попробовать решить задачу для 100 городов сделать вовремя не удастся
солнце погаснет быстрее

это знаменитая не решенная задача в области теории вычислений
для нее не существует быстрого алгоритма и найти такой невозможно
в лучшем случае можно найти приближенное решение

* Бинарный поиск работает намного быстрее простого.

* Время выполнения O(log п) быстрее О(п), а с увеличением размера спи­
ска, в котором ищется значение, оно становится намного быстрее.

* Время выполнения алгоритма описывается ростом количества операций.

* Время выполнения алгоритмов выражается как «О-большое~.















