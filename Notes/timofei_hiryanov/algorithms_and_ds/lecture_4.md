Тайм-коды: Функции
* 0:41 Определение простой функции def hello():  # definition/определение
* 1:43 Вызов функции hello() <- скобки - это вызов. Если имя без скобок, то это просто упоминание
* 2:11 синоним функции методом присваивания. f = hello  # теперь f - ссылка на ту же самую функцию
* 3:06 функция, как подпрограмма
* 3:18 описание функции с параметрами
* 3:42 формальный параметр
* 3:58 несколько параметров - через запятую  # print("Hello", name)
* 4:17 фактический параметр. Вызов функции, которая требует параметр
* 4:56 значения параметров по умолчанию. Функция с необязательным параметром # def hello(name = "World")
* 6:47 чистая функция. Функция ничего не должна требовать, кроме тех параметров, которые ей даны
* 7:00 return. Что функция возвращает. Ниже него ничего не выполнится, а будет выход из функции
* 11:53 функция, определяющая большее из 3
* 17:39 Полиморфизм в Python. Duck typing (Утиная типизация)
* 19:17 лексико-графический порядок сравнения строк
* 21:23 hello_separated
* 23:48 именованные параметры функции. sep в print
* 25:48 вызов функции с разным написанием параметров
* 28:50 синхронность работы функции (не асинхронное выполнение, не параллельное программирование)
* 30:35 Стек вызовов (Call stack) структура данных в памяти, в которую набрасываются адреса возврата
* 32:02 main. Главный модуль
* 36:16 Структурное программирование
* 38:41 функции нужны для повторяющихся участков кода
* 38:52 парадигма(метод, шаблон мышления)
* 39:02 Декомпозиция задачи. Проектирование "сверху-вниз". Формализация задачи. 
Формализовать имя функции, список параметров и возвращаемое значение. Иллюстрация
* 43:06 код. Документ-строка  #  """ """ сразу под именем функции
* 45:29 mock-функция (пустышка, заглушка, заготовка) Функция с pass
* 48:21 консистентное состояние программы. Без ошибок. Первая итерация разработки
* 48:52 продолжение иллюстрации
* 50:39 алгоритм от верхней функции вниз. Последовательность разработки (проектирования)
* 52:07 тестирование
* 53:46 timeline разработки программного продукта (взлет и приземление)
* 55:00 код. Продумка имени/функционала
* 1:01:50 метод грубой силы (Brute force) метод решения задач перебором всех ответов
область определения. Множество значений
* 1:04:16 алгоритмы brute force:
* 1:04:30 1) код. тест просторы числа
* 1:05:18 многострочная документ-строка. Теперь она добавилась в help
* 1:08:27 подсказки в среде разработки (инфа из док-строки)
* 1:08:42 help(is_simple_number)
* 1:09:32 документ-строки писать надо на английском языке. Имена функции длинными именами
* 1:10:18 2)код. факторизация (разложение числа на множители)


что такое фукции

структурное программирование 

используй все возможности функции

# проктрование сверху вниз
от высоких уровней абстракции к низким

1) то есть нужен дом.
2) создаем функцию home builder
3) внутри нее вызываем архитектора чтобы получить документацию
4) доку передаем прорабу он вернет дом
5) менеджер передает приемщщику дом для теста если все ок результат если нет братно передаем
прорабо на доработку а потом опять к приемщику пока не будет готово

пока просто в уме думаем как спроектировать программу не пишем реализацию кокретных функций

вообще нагляднее в картинке рассматривать все это 

6) вот например у нас есть функция прораб он зовет бригадиров 1 2 3 

итеративный метод разработки когда по чучуть делаешь и улучшаеш программу но она всегда рабочая

# Метод гурбой силы

* область оперделения
* множество значений

когда приходится пробегаться по всему множеству значений чтобы найти правильный ответ то это брут форс

examples of brute force

def is_simple_number(x):
    пробегаемся по всей последовательности

def factorize_number(x):
    пробегаемся по всей последовательности


