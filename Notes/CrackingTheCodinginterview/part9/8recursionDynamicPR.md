#Рекурсия и динамическое прораммирование

Рекурсивные решения по определению основываются на решении подзадач

Существует много способов деления задачи на подзадачи. Три самых распро­
страненных метода разработки алгоритма - восходящий, нисходящи й и по­
ловинчатый

##Восходящая рекурсия

Восходящая рекурсия обычно более понятна на интуитивном уровне. Вы знаете,
как решить задачу для самого простого случая - например, для списка всего с од­
ним элементом. Затем задача решается для двух элементов, затем для трех и т. д.
Подумайте о том, как построить решение для конкретного случая, основываясь на
решении для предыдущего случая ( или нескольких предыдущих случаев).

##Нисходящая рекурсия 

Н исходящая рекурсия выглядит более сложной, так как она менее конкретна.
Тем не менее в отдельных случаях такой подход к решению задачи оказывается
оптимальным.
В этом случае необходимо решить, как разделить задачу для случая N на подзадачи.
Будьте осторожны с перекрывающимися случаями.

##Половинчатая рекурсия

Помимо восходящей и нисходящей рекурсии также часто эффективно работает
метод разбиения набора данных на две половины

Например, алгоритм бинарной сортировки основан на « половинчатом» методе.
При поиске элемента в отсортированном массиве вы сначала определяете, какая
половина массива содержит искомое значение. Затем происходит рекурсивный
переход, и поиск продолжается в выбранной половине.
Алгоритм сортировки слиянием также относится к « половинчатым» методам.
Каждая половина массива сортируется по отдельности, после чего отсортированные
половины объединяются

## Решения рекурсивные и итеративные

Рекурсивные алгоритмы могут быть весьма неэффективны по затратам памяти.
Каждый рекурсивный вызов добавляет новый уровень в стек; это означает, что
если алгоритм проводит рекурсию до уровня п, он использует как минимум О(п)
памяти.
По этой причине часто бывает лучше реализовать рекурсивный алгоритм в итера­
тивном виде. Все рекурсивные алгоритмы могут быть реализованы в итеративном
виде, хотя иногда это приводит к существенному усложнению кода. Прежде чем
браться за рекурсивный код, спросите себя, насколько сложно будет реализовать
его в итеративном виде, и обсудите достоинства и недостатки каждого варианта
с интервьюером.

##Динамическое программирование и мемоизация

Методология динамического программирования в основном сводится к определе­
нию рекурсивного алгоритма и нахождению перекрывающихся подзадач. Полу­
ченные результаты кэшируются для будущих рекурсивных вызовов.

Хороший подход к задачам такого рода часто заключается
в том, чтобы реализовать задачу в обычном рекурсивном виде, а затем добавить
в решение кэширование.

###Нисходящее динамическое программирование ( или мемоизация)

Каждый раз, когда мы вычисляем fib ( i ) , результат следует
просто кэшировать и использовать его в будущем.
Именно в этом и заключается суть мемоизации.

если кэшировать то время улучшится из O(n!) до O(n)

###Восходящее динамическое программирование

Считайте, что происходит то же самое, что и при
рекурсивном подходе с мемоизацией, но в обратном порядке.










